From 1dd307e5b6120ec2d9693a55527d3e630f940afb Mon Sep 17 00:00:00 2001
From: Zofia Abramowska <z.abramowska@samsung.com>
Date: Thu, 11 Apr 2013 15:31:45 +0200
Subject: [PATCH] Removing obsolete SMACK patches

Adding current patches for enabling SMACK
Adding runtime check for SMACK

Change-Id: Ic74c4f3cfc483d3d9da470a1ee84eca033b50ecc
---
 ...> 0001-dbus_service_highest_prio_setting.patch} |    0
 ...ions.patch => 0002-slp-relax-permissions.patch} |    0
 ...patch => 0003-slp-add-services-directory.patch} |    0
 ...d-Make-disable-xml-docs-build-work-again.patch} |    0
 ...rrect-address-when-using-address-systemd.patch} |    0
 ...everybody-send-messages-to-system-dbus-s.patch} |    0
 ...ch => 0007-Dbus-environment-value-define.patch} |    0
 ...factor-out-common-code-to-get-a-named-con.patch |  258 +++++++
 ...v-helpers-from-Stats-into-generic-utility.patch |  701 ++++++++++++++++++++
 packaging/0010-GetConnectionCredentials-add.patch  |  361 ++++++++++
 ...> 0011-Store-Smack-context-of-connection.patch} |  311 +++++-----
 ...Smack-context-with-connection-credentials.patch |   67 ++
 ...0013-Enforce-Smack-policy-from-conf-file.patch} |  270 ++++-----
 packaging/adding-run-time-check-for-SMACK.patch    |  121 ++++
 packaging/dbus.spec                                |   29 +-
 15 files changed, 1801 insertions(+), 317 deletions(-)
 rename packaging/{0003-dbus_service_highest_prio_setting.patch => 0001-dbus_service_highest_prio_setting.patch} (100%)
 rename packaging/{slp-relax-permissions.patch => 0002-slp-relax-permissions.patch} (100%)
 rename packaging/{slp-add-services-directory.patch => 0003-slp-add-services-directory.patch} (100%)
 rename packaging/{0006-build-Make-disable-xml-docs-build-work-again.patch => 0004-build-Make-disable-xml-docs-build-work-again.patch} (100%)
 rename packaging/{0007-Set-correct-address-when-using-address-systemd.patch => 0005-Set-correct-address-when-using-address-systemd.patch} (100%)
 rename packaging/{0008-smack-Allow-everybody-send-messages-to-system-dbus-s.patch => 0006-smack-Allow-everybody-send-messages-to-system-dbus-s.patch} (100%)
 rename packaging/{0009-Dbus-environment-value-define.patch => 0007-Dbus-environment-value-define.patch} (100%)
 create mode 100644 packaging/0008-bus-driver-factor-out-common-code-to-get-a-named-con.patch
 create mode 100644 packaging/0009-Convert-a-sv-helpers-from-Stats-into-generic-utility.patch
 create mode 100644 packaging/0010-GetConnectionCredentials-add.patch
 rename packaging/{0001-Enable-checking-of-smack-context-from-DBus-interface.patch => 0011-Store-Smack-context-of-connection.patch} (51%)
 create mode 100644 packaging/0012-Return-Smack-context-with-connection-credentials.patch
 rename packaging/{0002-Enforce-smack-policy-from-conf-file.patch => 0013-Enforce-Smack-policy-from-conf-file.patch} (59%)
 create mode 100644 packaging/adding-run-time-check-for-SMACK.patch

diff --git a/packaging/0003-dbus_service_highest_prio_setting.patch b/packaging/0001-dbus_service_highest_prio_setting.patch
similarity index 100%
rename from packaging/0003-dbus_service_highest_prio_setting.patch
rename to packaging/0001-dbus_service_highest_prio_setting.patch
diff --git a/packaging/slp-relax-permissions.patch b/packaging/0002-slp-relax-permissions.patch
similarity index 100%
rename from packaging/slp-relax-permissions.patch
rename to packaging/0002-slp-relax-permissions.patch
diff --git a/packaging/slp-add-services-directory.patch b/packaging/0003-slp-add-services-directory.patch
similarity index 100%
rename from packaging/slp-add-services-directory.patch
rename to packaging/0003-slp-add-services-directory.patch
diff --git a/packaging/0006-build-Make-disable-xml-docs-build-work-again.patch b/packaging/0004-build-Make-disable-xml-docs-build-work-again.patch
similarity index 100%
rename from packaging/0006-build-Make-disable-xml-docs-build-work-again.patch
rename to packaging/0004-build-Make-disable-xml-docs-build-work-again.patch
diff --git a/packaging/0007-Set-correct-address-when-using-address-systemd.patch b/packaging/0005-Set-correct-address-when-using-address-systemd.patch
similarity index 100%
rename from packaging/0007-Set-correct-address-when-using-address-systemd.patch
rename to packaging/0005-Set-correct-address-when-using-address-systemd.patch
diff --git a/packaging/0008-smack-Allow-everybody-send-messages-to-system-dbus-s.patch b/packaging/0006-smack-Allow-everybody-send-messages-to-system-dbus-s.patch
similarity index 100%
rename from packaging/0008-smack-Allow-everybody-send-messages-to-system-dbus-s.patch
rename to packaging/0006-smack-Allow-everybody-send-messages-to-system-dbus-s.patch
diff --git a/packaging/0009-Dbus-environment-value-define.patch b/packaging/0007-Dbus-environment-value-define.patch
similarity index 100%
rename from packaging/0009-Dbus-environment-value-define.patch
rename to packaging/0007-Dbus-environment-value-define.patch
diff --git a/packaging/0008-bus-driver-factor-out-common-code-to-get-a-named-con.patch b/packaging/0008-bus-driver-factor-out-common-code-to-get-a-named-con.patch
new file mode 100644
index 0000000..ae3c49c
--- /dev/null
+++ b/packaging/0008-bus-driver-factor-out-common-code-to-get-a-named-con.patch
@@ -0,0 +1,258 @@
+From 4f9183dcc843e81b1a2c9671b3dad34fb6ce7df3 Mon Sep 17 00:00:00 2001
+From: Simon McVittie <simon.mcvittie@collabora.co.uk>
+Date: Wed, 28 Mar 2012 16:39:09 +0100
+Subject: [PATCH] bus driver: factor out common code to get a named connection
+
+Signed-off-by: Simon McVittie <simon.mcvittie@collabora.co.uk>
+Bug: https://bugs.freedesktop.org/show_bug.cgi?id=54445
+---
+ bus/driver.c | 160 ++++++++++++++++++++++++-----------------------------------
+ 1 file changed, 64 insertions(+), 96 deletions(-)
+
+diff --git a/bus/driver.c b/bus/driver.c
+index 574e0f3..6ccd6d6 100644
+--- a/bus/driver.c
++++ b/bus/driver.c
+@@ -32,12 +32,56 @@
+ #include "signals.h"
+ #include "stats.h"
+ #include "utils.h"
++
++#include <dbus/dbus-asv-util.h>
+ #include <dbus/dbus-string.h>
+ #include <dbus/dbus-internals.h>
+ #include <dbus/dbus-message.h>
+ #include <dbus/dbus-marshal-recursive.h>
+ #include <string.h>
+ 
++static DBusConnection *
++bus_driver_get_conn_helper (DBusConnection  *connection,
++                            DBusMessage     *message,
++                            const char      *what_we_want,
++                            const char     **name_p,
++                            DBusError       *error)
++{
++  const char *name;
++  BusRegistry *registry;
++  BusService *serv;
++  DBusString str;
++  DBusConnection *conn;
++
++  if (!dbus_message_get_args (message, error,
++                              DBUS_TYPE_STRING, &name,
++                              DBUS_TYPE_INVALID))
++    return NULL;
++
++  _dbus_assert (name != NULL);
++  _dbus_verbose ("asked for %s of connection %s\n", what_we_want, name);
++
++  registry = bus_connection_get_registry (connection);
++  _dbus_string_init_const (&str, name);
++  serv = bus_registry_lookup (registry, &str);
++
++  if (serv == NULL)
++    {
++      dbus_set_error (error, DBUS_ERROR_NAME_HAS_NO_OWNER,
++                      "Could not get %s of name '%s': no such name",
++                      what_we_want, name);
++      return NULL;
++    }
++
++  conn = bus_service_get_primary_owners_connection (serv);
++  _dbus_assert (conn != NULL);
++
++  if (name_p != NULL)
++    *name_p = name;
++
++  return conn;
++}
++
+ static dbus_bool_t bus_driver_send_welcome_message (DBusConnection *connection,
+                                                     DBusMessage    *hello_message,
+                                                     BusTransaction *transaction,
+@@ -1262,40 +1306,21 @@ static dbus_bool_t bus_driver_send_welcome_message (DBusConnection *connection,
+                                             DBusMessage    *message,
+                                             DBusError      *error)
+ {
+-  const char *service;
+-  DBusString str;
+-  BusRegistry *registry;
+-  BusService *serv;
+   DBusConnection *conn;
+   DBusMessage *reply;
+   unsigned long uid;
+   dbus_uint32_t uid32;
++  const char *service;
+ 
+   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
+ 
+-  registry = bus_connection_get_registry (connection);
+-
+-  service = NULL;
+   reply = NULL;
+ 
+-  if (! dbus_message_get_args (message, error,
+-			       DBUS_TYPE_STRING, &service,
+-			       DBUS_TYPE_INVALID))
+-      goto failed;
+-
+-  _dbus_verbose ("asked for UID of connection %s\n", service);
+-
+-  _dbus_string_init_const (&str, service);
+-  serv = bus_registry_lookup (registry, &str);
+-  if (serv == NULL)
+-    {
+-      dbus_set_error (error,
+-		      DBUS_ERROR_NAME_HAS_NO_OWNER,
+-		      "Could not get UID of name '%s': no such name", service);
+-      goto failed;
+-    }
++  conn = bus_driver_get_conn_helper (connection, message, "UID", &service,
++                                     error);
+ 
+-  conn = bus_service_get_primary_owners_connection (serv);
++  if (conn == NULL)
++    goto failed;
+ 
+   reply = dbus_message_new_method_return (message);
+   if (reply == NULL)
+@@ -1338,40 +1363,21 @@ static dbus_bool_t bus_driver_send_welcome_message (DBusConnection *connection,
+ 						  DBusMessage    *message,
+ 						  DBusError      *error)
+ {
+-  const char *service;
+-  DBusString str;
+-  BusRegistry *registry;
+-  BusService *serv;
+   DBusConnection *conn;
+   DBusMessage *reply;
+   unsigned long pid;
+   dbus_uint32_t pid32;
++  const char *service;
+ 
+   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
+ 
+-  registry = bus_connection_get_registry (connection);
+-
+-  service = NULL;
+   reply = NULL;
+ 
+-  if (! dbus_message_get_args (message, error,
+-			       DBUS_TYPE_STRING, &service,
+-			       DBUS_TYPE_INVALID))
+-      goto failed;
+-
+-  _dbus_verbose ("asked for PID of connection %s\n", service);
+-
+-  _dbus_string_init_const (&str, service);
+-  serv = bus_registry_lookup (registry, &str);
+-  if (serv == NULL)
+-    {
+-      dbus_set_error (error,
+-		      DBUS_ERROR_NAME_HAS_NO_OWNER,
+-		      "Could not get PID of name '%s': no such name", service);
+-      goto failed;
+-    }
++  conn = bus_driver_get_conn_helper (connection, message, "PID", &service,
++                                     error);
+ 
+-  conn = bus_service_get_primary_owners_connection (serv);
++  if (conn == NULL)
++    goto failed;
+ 
+   reply = dbus_message_new_method_return (message);
+   if (reply == NULL)
+@@ -1414,40 +1420,21 @@ static dbus_bool_t bus_driver_send_welcome_message (DBusConnection *connection,
+ 					      DBusMessage    *message,
+ 					      DBusError      *error)
+ {
+-  const char *service;
+-  DBusString str;
+-  BusRegistry *registry;
+-  BusService *serv;
+   DBusConnection *conn;
+   DBusMessage *reply;
+   void *data = NULL;
+   dbus_uint32_t data_size;
++  const char *service;
+ 
+   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
+ 
+-  registry = bus_connection_get_registry (connection);
+-
+-  service = NULL;
+   reply = NULL;
+ 
+-  if (! dbus_message_get_args (message, error,
+-			       DBUS_TYPE_STRING, &service,
+-			       DBUS_TYPE_INVALID))
+-      goto failed;
+-
+-  _dbus_verbose ("asked for audit session data for connection %s\n", service);
++  conn = bus_driver_get_conn_helper (connection, message,
++                                     "audit session data", &service, error);
+ 
+-  _dbus_string_init_const (&str, service);
+-  serv = bus_registry_lookup (registry, &str);
+-  if (serv == NULL)
+-    {
+-      dbus_set_error (error,
+-		      DBUS_ERROR_NAME_HAS_NO_OWNER,
+-		      "Could not get audit session data for name '%s': no such name", service);
+-      goto failed;
+-    }
+-
+-  conn = bus_service_get_primary_owners_connection (serv);
++  if (conn == NULL)
++    goto failed;
+ 
+   reply = dbus_message_new_method_return (message);
+   if (reply == NULL)
+@@ -1489,39 +1476,20 @@ static dbus_bool_t bus_driver_send_welcome_message (DBusConnection *connection,
+ 							   DBusMessage    *message,
+ 							   DBusError      *error)
+ {
+-  const char *service;
+-  DBusString str;
+-  BusRegistry *registry;
+-  BusService *serv;
+   DBusConnection *conn;
+   DBusMessage *reply;
+   BusSELinuxID *context;
++  const char *service;
+ 
+   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
+ 
+-  registry = bus_connection_get_registry (connection);
+-
+-  service = NULL;
+   reply = NULL;
+ 
+-  if (! dbus_message_get_args (message, error,
+-			       DBUS_TYPE_STRING, &service,
+-			       DBUS_TYPE_INVALID))
+-      goto failed;
+-
+-  _dbus_verbose ("asked for security context of connection %s\n", service);
++  conn = bus_driver_get_conn_helper (connection, message, "security context",
++                                     &service, error);
+ 
+-  _dbus_string_init_const (&str, service);
+-  serv = bus_registry_lookup (registry, &str);
+-  if (serv == NULL)
+-    {
+-      dbus_set_error (error,
+-		      DBUS_ERROR_NAME_HAS_NO_OWNER,
+-		      "Could not get security context of name '%s': no such name", service);
+-      goto failed;
+-    }
+-
+-  conn = bus_service_get_primary_owners_connection (serv);
++  if (conn == NULL)
++    goto failed;
+ 
+   reply = dbus_message_new_method_return (message);
+   if (reply == NULL)
+-- 
+1.8.1.5
+
diff --git a/packaging/0009-Convert-a-sv-helpers-from-Stats-into-generic-utility.patch b/packaging/0009-Convert-a-sv-helpers-from-Stats-into-generic-utility.patch
new file mode 100644
index 0000000..94de8c5
--- /dev/null
+++ b/packaging/0009-Convert-a-sv-helpers-from-Stats-into-generic-utility.patch
@@ -0,0 +1,701 @@
+From dd272180e0493530ec37147fce6432646adb9665 Mon Sep 17 00:00:00 2001
+From: Simon McVittie <simon.mcvittie@collabora.co.uk>
+Date: Wed, 28 Mar 2012 16:40:10 +0100
+Subject: [PATCH] Convert a{sv} helpers from Stats into generic utility code
+
+Signed-off-by: Simon McVittie <simon.mcvittie@collabora.co.uk>
+Bug: https://bugs.freedesktop.org/show_bug.cgi?id=54445
+---
+ bus/stats.c               | 239 ++++++++++--------------------------------
+ cmake/dbus/CMakeLists.txt |   2 +
+ dbus/Makefile.am          |   2 +
+ dbus/dbus-asv-util.c      | 260 ++++++++++++++++++++++++++++++++++++++++++++++
+ dbus/dbus-asv-util.h      |  57 ++++++++++
+ 5 files changed, 373 insertions(+), 187 deletions(-)
+ create mode 100644 dbus/dbus-asv-util.c
+ create mode 100644 dbus/dbus-asv-util.h
+
+diff --git a/bus/stats.c b/bus/stats.c
+index 28fd49b..496ca6d 100644
+--- a/bus/stats.c
++++ b/bus/stats.c
+@@ -1,5 +1,7 @@
+ /* stats.c - statistics from the bus driver
+  *
++ * Copyright © 2011-2012 Nokia Corporation
++ *
+  * Licensed under the Academic Free License version 2.1
+  *
+  * This program is free software; you can redistribute it and/or modify
+@@ -21,6 +23,7 @@
+ #include <config.h>
+ #include "stats.h"
+ 
++#include <dbus/dbus-asv-util.h>
+ #include <dbus/dbus-internals.h>
+ #include <dbus/dbus-connection-internal.h>
+ 
+@@ -30,153 +33,6 @@
+ 
+ #ifdef DBUS_ENABLE_STATS
+ 
+-static DBusMessage *
+-new_asv_reply (DBusMessage      *message,
+-               DBusMessageIter  *iter,
+-               DBusMessageIter  *arr_iter)
+-{
+-  DBusMessage *reply = dbus_message_new_method_return (message);
+-
+-  if (reply == NULL)
+-    return NULL;
+-
+-  dbus_message_iter_init_append (reply, iter);
+-
+-  if (!dbus_message_iter_open_container (iter, DBUS_TYPE_ARRAY, "{sv}",
+-                                         arr_iter))
+-    {
+-      dbus_message_unref (reply);
+-      return NULL;
+-    }
+-
+-  return reply;
+-}
+-
+-static dbus_bool_t
+-open_asv_entry (DBusMessageIter *arr_iter,
+-                DBusMessageIter *entry_iter,
+-                const char      *key,
+-                const char      *type,
+-                DBusMessageIter *var_iter)
+-{
+-  if (!dbus_message_iter_open_container (arr_iter, DBUS_TYPE_DICT_ENTRY,
+-                                         NULL, entry_iter))
+-    return FALSE;
+-
+-  if (!dbus_message_iter_append_basic (entry_iter, DBUS_TYPE_STRING, &key))
+-    {
+-      dbus_message_iter_abandon_container (arr_iter, entry_iter);
+-      return FALSE;
+-    }
+-
+-  if (!dbus_message_iter_open_container (entry_iter, DBUS_TYPE_VARIANT,
+-                                         type, var_iter))
+-    {
+-      dbus_message_iter_abandon_container (arr_iter, entry_iter);
+-      return FALSE;
+-    }
+-
+-  return TRUE;
+-}
+-
+-static dbus_bool_t
+-close_asv_entry (DBusMessageIter *arr_iter,
+-                 DBusMessageIter *entry_iter,
+-                 DBusMessageIter *var_iter)
+-{
+-  if (!dbus_message_iter_close_container (entry_iter, var_iter))
+-    {
+-      dbus_message_iter_abandon_container (arr_iter, entry_iter);
+-      return FALSE;
+-    }
+-
+-  if (!dbus_message_iter_close_container (arr_iter, entry_iter))
+-    return FALSE;
+-
+-  return TRUE;
+-}
+-
+-static dbus_bool_t
+-close_asv_reply (DBusMessageIter *iter,
+-                 DBusMessageIter *arr_iter)
+-{
+-  return dbus_message_iter_close_container (iter, arr_iter);
+-}
+-
+-static void
+-abandon_asv_entry (DBusMessageIter *arr_iter,
+-                   DBusMessageIter *entry_iter,
+-                   DBusMessageIter *var_iter)
+-{
+-  dbus_message_iter_abandon_container (entry_iter, var_iter);
+-  dbus_message_iter_abandon_container (arr_iter, entry_iter);
+-}
+-
+-static void
+-abandon_asv_reply (DBusMessageIter *iter,
+-                 DBusMessageIter *arr_iter)
+-{
+-  dbus_message_iter_abandon_container (iter, arr_iter);
+-}
+-
+-static dbus_bool_t
+-asv_add_uint32 (DBusMessageIter *iter,
+-                DBusMessageIter *arr_iter,
+-                const char *key,
+-                dbus_uint32_t value)
+-{
+-  DBusMessageIter entry_iter, var_iter;
+-
+-  if (!open_asv_entry (arr_iter, &entry_iter, key, DBUS_TYPE_UINT32_AS_STRING,
+-                       &var_iter))
+-    goto oom;
+-
+-  if (!dbus_message_iter_append_basic (&var_iter, DBUS_TYPE_UINT32,
+-                                       &value))
+-    {
+-      abandon_asv_entry (arr_iter, &entry_iter, &var_iter);
+-      goto oom;
+-    }
+-
+-  if (!close_asv_entry (arr_iter, &entry_iter, &var_iter))
+-    goto oom;
+-
+-  return TRUE;
+-
+-oom:
+-  abandon_asv_reply (iter, arr_iter);
+-  return FALSE;
+-}
+-
+-static dbus_bool_t
+-asv_add_string (DBusMessageIter *iter,
+-                DBusMessageIter *arr_iter,
+-                const char *key,
+-                const char *value)
+-{
+-  DBusMessageIter entry_iter, var_iter;
+-
+-  if (!open_asv_entry (arr_iter, &entry_iter, key, DBUS_TYPE_STRING_AS_STRING,
+-                       &var_iter))
+-    goto oom;
+-
+-  if (!dbus_message_iter_append_basic (&var_iter, DBUS_TYPE_STRING,
+-                                       &value))
+-    {
+-      abandon_asv_entry (arr_iter, &entry_iter, &var_iter);
+-      goto oom;
+-    }
+-
+-  if (!close_asv_entry (arr_iter, &entry_iter, &var_iter))
+-    goto oom;
+-
+-  return TRUE;
+-
+-oom:
+-  abandon_asv_reply (iter, arr_iter);
+-  return FALSE;
+-}
+-
+ dbus_bool_t
+ bus_stats_handle_get_stats (DBusConnection *connection,
+                             BusTransaction *transaction,
+@@ -193,47 +49,50 @@
+ 
+   connections = bus_transaction_get_connections (transaction);
+ 
+-  reply = new_asv_reply (message, &iter, &arr_iter);
++  reply = _dbus_asv_new_method_return (message, &iter, &arr_iter);
+ 
+   if (reply == NULL)
+     goto oom;
+ 
+   /* Globals */
+ 
+-  if (!asv_add_uint32 (&iter, &arr_iter, "Serial", stats_serial++))
+-    goto oom;
+-
+   _dbus_list_get_stats (&in_use, &in_free_list, &allocated);
+-  if (!asv_add_uint32 (&iter, &arr_iter, "ListMemPoolUsedBytes", in_use) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "ListMemPoolCachedBytes",
+-                       in_free_list) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "ListMemPoolAllocatedBytes",
+-                       allocated))
+-    goto oom;
++
++  if (!_dbus_asv_add_uint32 (&arr_iter, "Serial", stats_serial++) ||
++      !asv_add_uint32 (&arr_iter, "ListMemPoolUsedBytes", in_use) ||
++      !asv_add_uint32 (&arr_iter, "ListMemPoolCachedBytes", in_free_list) ||
++      !asv_add_uint32 (&arr_iter, "ListMemPoolAllocatedBytes", allocated))
++    {
++      _dbus_asv_abandon (&iter, &arr_iter);
++      goto oom;
++    }
+ 
+   /* Connections */
+ 
+-  if (!asv_add_uint32 (&iter, &arr_iter, "ActiveConnections",
++  if (!_dbus_asv_add_uint32 (&arr_iter, "ActiveConnections",
+         bus_connections_get_n_active (connections)) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "IncompleteConnections",
++      !_dbus_asv_add_uint32 (&arr_iter, "IncompleteConnections",
+         bus_connections_get_n_incomplete (connections)) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "MatchRules",
++      !_dbus_asv_add_uint32 (&arr_iter, "MatchRules",
+         bus_connections_get_total_match_rules (connections)) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "PeakMatchRules",
++      !_dbus_asv_add_uint32 (&arr_iter, "PeakMatchRules",
+         bus_connections_get_peak_match_rules (connections)) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "PeakMatchRulesPerConnection",
++      !_dbus_asv_add_uint32 (&arr_iter, "PeakMatchRulesPerConnection",
+         bus_connections_get_peak_match_rules_per_conn (connections)) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "BusNames",
++      !_dbus_asv_add_uint32 (&arr_iter, "BusNames",
+         bus_connections_get_total_bus_names (connections)) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "PeakBusNames",
++      !_dbus_asv_add_uint32 (&arr_iter, "PeakBusNames",
+         bus_connections_get_peak_bus_names (connections)) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "PeakBusNamesPerConnection",
++      !_dbus_asv_add_uint32 (&arr_iter, "PeakBusNamesPerConnection",
+         bus_connections_get_peak_bus_names_per_conn (connections)))
+-    goto oom;
++    {
++      _dbus_asv_abandon (&iter, &arr_iter);
++      goto oom;
++    }
+ 
+   /* end */
+ 
+-  if (!close_asv_reply (&iter, &arr_iter))
++  if (!_dbus_asv_close (&iter, &arr_iter))
+     goto oom;
+ 
+   if (!bus_transaction_send_from_driver (transaction, connection, reply))
+@@ -289,25 +148,28 @@
+   stats_connection = bus_service_get_primary_owners_connection (service);
+   _dbus_assert (stats_connection != NULL);
+ 
+-  reply = new_asv_reply (message, &iter, &arr_iter);
++  reply = _dbus_asv_new_method_return (message, &iter, &arr_iter);
+ 
+   if (reply == NULL)
+     goto oom;
+ 
+   /* Bus daemon per-connection stats */
+ 
+-  if (!asv_add_uint32 (&iter, &arr_iter, "Serial", stats_serial++) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "MatchRules",
++  if (!_dbus_asv_add_uint32 (&arr_iter, "Serial", stats_serial++) ||
++      !_dbus_asv_add_uint32 (&arr_iter, "MatchRules",
+         bus_connection_get_n_match_rules (stats_connection)) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "PeakMatchRules",
++      !_dbus_asv_add_uint32 (&arr_iter, "PeakMatchRules",
+         bus_connection_get_peak_match_rules (stats_connection)) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "BusNames",
++      !_dbus_asv_add_uint32 (&arr_iter, "BusNames",
+         bus_connection_get_n_services_owned (stats_connection)) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "PeakBusNames",
++      !_dbus_asv_add_uint32 (&arr_iter, "PeakBusNames",
+         bus_connection_get_peak_bus_names (stats_connection)) ||
+-      !asv_add_string (&iter, &arr_iter, "UniqueName",
++      !_dbus_asv_add_uint32 (&arr_iter, "UniqueName",
+         bus_connection_get_name (stats_connection)))
+-    goto oom;
++    {
++      _dbus_asv_abandon (&iter, &arr_iter);
++      goto oom;
++    }
+ 
+   /* DBusConnection per-connection stats */
+ 
+@@ -317,21 +179,24 @@
+                               &out_messages, &out_bytes, &out_fds,
+                               &out_peak_bytes, &out_peak_fds);
+ 
+-  if (!asv_add_uint32 (&iter, &arr_iter, "IncomingMessages", in_messages) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "IncomingBytes", in_bytes) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "IncomingFDs", in_fds) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "PeakIncomingBytes", in_peak_bytes) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "PeakIncomingFDs", in_peak_fds) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "OutgoingMessages", out_messages) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "OutgoingBytes", out_bytes) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "OutgoingFDs", out_fds) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "PeakOutgoingBytes", out_peak_bytes) ||
+-      !asv_add_uint32 (&iter, &arr_iter, "PeakOutgoingFDs", out_peak_fds))
+-    goto oom;
++  if (!_dbus_asv_add_uint32 (&arr_iter, "IncomingMessages", in_messages) ||
++      !_dbus_asv_add_uint32 (&arr_iter, "IncomingBytes", in_bytes) ||
++      !_dbus_asv_add_uint32 (&arr_iter, "IncomingFDs", in_fds) ||
++      !_dbus_asv_add_uint32 (&arr_iter, "PeakIncomingBytes", in_peak_bytes) ||
++      !_dbus_asv_add_uint32 (&arr_iter, "PeakIncomingFDs", in_peak_fds) ||
++      !_dbus_asv_add_uint32 (&arr_iter, "OutgoingMessages", out_messages) ||
++      !_dbus_asv_add_uint32 (&arr_iter, "OutgoingBytes", out_bytes) ||
++      !_dbus_asv_add_uint32 (&arr_iter, "OutgoingFDs", out_fds) ||
++      !_dbus_asv_add_uint32 (&arr_iter, "PeakOutgoingBytes", out_peak_bytes) ||
++      !_dbus_asv_add_uint32 (&arr_iter, "PeakOutgoingFDs", out_peak_fds))
++    {
++      _dbus_asv_abandon (&iter, &arr_iter);
++      goto oom;
++    }
+ 
+   /* end */
+ 
+-  if (!close_asv_reply (&iter, &arr_iter))
++  if (!_dbus_asv_close (&iter, &arr_iter))
+     goto oom;
+ 
+   if (!bus_transaction_send_from_driver (transaction, caller_connection,
+diff --git a/cmake/dbus/CMakeLists.txt b/cmake/dbus/CMakeLists.txt
+index d09e63d..549bc8a 100644
+--- a/cmake/dbus/CMakeLists.txt
++++ b/cmake/dbus/CMakeLists.txt
+@@ -149,6 +149,7 @@ set (DBUS_SHARED_HEADERS
+ ### should be underscore-prefixed but don't really need 
+ ### to be unless they move to DBUS_SHARED_SOURCES later)
+ set (DBUS_UTIL_SOURCES
++	${DBUS_DIR}/dbus-asv-util.c
+ 	${DBUS_DIR}/dbus-auth-script.c
+ 	${DBUS_DIR}/dbus-auth-util.c
+ 	${DBUS_DIR}/dbus-credentials-util.c
+@@ -173,6 +174,7 @@ if (DBUS_BUILD_TESTS)
+ endif (DBUS_BUILD_TESTS)
+ 
+ set (DBUS_UTIL_HEADERS
++	${DBUS_DIR}/dbus-asv-util.h
+ 	${DBUS_DIR}/dbus-auth-script.h
+ 	${DBUS_DIR}/dbus-mainloop.h
+ 	${DBUS_DIR}/dbus-message-factory.h
+diff --git a/dbus/Makefile.am b/dbus/Makefile.am
+index bb5ccca..d9ef748 100644
+--- a/dbus/Makefile.am
++++ b/dbus/Makefile.am
+@@ -233,6 +233,8 @@ DBUS_SHARED_SOURCES=				\
+ ### should be underscore-prefixed but don't really need
+ ### to be unless they move to DBUS_SHARED_SOURCES later)
+ DBUS_UTIL_SOURCES=				\
++	dbus-asv-util.c				\
++	dbus-asv-util.h				\
+ 	dbus-auth-script.c			\
+ 	dbus-auth-script.h			\
+ 	dbus-auth-util.c			\
+diff --git a/dbus/dbus-asv-util.c b/dbus/dbus-asv-util.c
+new file mode 100644
+index 0000000..4040a40
+--- /dev/null
++++ b/dbus/dbus-asv-util.c
+@@ -0,0 +1,260 @@
++/* dbus-asv-util.c - utility functions for a{sv}
++ *
++ * Copyright © 2011-2012 Nokia Corporation
++ * Copyright © 2012 Collabora Ltd.
++ *
++ * Licensed under the Academic Free License version 2.1
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++
++#include <config.h>
++
++#include <dbus/dbus.h>
++
++#include "dbus/dbus-asv-util.h"
++
++/**
++ * Convenience function to create a method-call reply whose type is a{sv}
++ * (map from string to variant).
++ *
++ * Append values with 0 or more sequences of _dbus_asv_open_entry(),
++ * appending a value to var_iter, and _dbus_asv_close_entry(),
++ * then close the a{sv} with _dbus_asv_close() or _dbus_asv_abandon().
++ *
++ * This must be paired with a call to _dbus_asv_close() or _dbus_asv_abandon().
++ *
++ * @param message a method call message
++ * @param iter an iterator which will be initialized to append to the message
++ * @param arr_iter an iterator which will be initialized to append to the array
++ * @returns a new message, or #NULL if not enough memory
++ */
++DBusMessage *
++_dbus_asv_new_method_return (DBusMessage      *message,
++                             DBusMessageIter  *iter,
++                             DBusMessageIter  *arr_iter)
++{
++  DBusMessage *reply = dbus_message_new_method_return (message);
++
++  if (reply == NULL)
++    return NULL;
++
++  dbus_message_iter_init_append (reply, iter);
++
++  if (!dbus_message_iter_open_container (iter, DBUS_TYPE_ARRAY, "{sv}",
++                                         arr_iter))
++    {
++      dbus_message_unref (reply);
++      return NULL;
++    }
++
++  return reply;
++}
++
++/**
++ * Open a new entry in an a{sv} (map from string to variant).
++ *
++ * This must be paired with a call to either _dbus_asv_close_entry()
++ * or _dbus_asv_abandon_entry().
++ *
++ * If this function fails, the a{sv} must be abandoned, for instance
++ * with _dbus_asv_abandon().
++ *
++ * @param arr_iter the iterator which is appending to the array
++ * @param entry_iter will be initialized to append to the dict-entry
++ * @param key a UTF-8 key for the map
++ * @param type the type of the variant value, e.g. DBUS_TYPE_STRING_AS_STRING
++ * @param var_iter will be initialized to append (i.e. write) to the variant
++ * @returns #TRUE on success, or #FALSE if not enough memory
++ */
++dbus_bool_t
++_dbus_asv_open_entry (DBusMessageIter *arr_iter,
++                      DBusMessageIter *entry_iter,
++                      const char      *key,
++                      const char      *type,
++                      DBusMessageIter *var_iter)
++{
++  if (!dbus_message_iter_open_container (arr_iter, DBUS_TYPE_DICT_ENTRY,
++                                         NULL, entry_iter))
++    return FALSE;
++
++  if (!dbus_message_iter_append_basic (entry_iter, DBUS_TYPE_STRING, &key))
++    {
++      dbus_message_iter_abandon_container (arr_iter, entry_iter);
++      return FALSE;
++    }
++
++  if (!dbus_message_iter_open_container (entry_iter, DBUS_TYPE_VARIANT,
++                                         type, var_iter))
++    {
++      dbus_message_iter_abandon_container (arr_iter, entry_iter);
++      return FALSE;
++    }
++
++  return TRUE;
++}
++
++/**
++ * Closes an a{sv} entry after successfully appending the value.
++ *
++ * If this function fails, the a{sv} must be abandoned, for instance
++ * with _dbus_asv_abandon().
++ *
++ * @param arr_iter the iterator which is appending to the array
++ * @param entry_iter the iterator appending to the dict-entry, will be closed
++ * @param var_iter the iterator appending to the variant, will be closed
++ * @returns #TRUE on success, or #FALSE if not enough memory
++ */
++dbus_bool_t
++_dbus_asv_close_entry (DBusMessageIter *arr_iter,
++                       DBusMessageIter *entry_iter,
++                       DBusMessageIter *var_iter)
++{
++  if (!dbus_message_iter_close_container (entry_iter, var_iter))
++    {
++      dbus_message_iter_abandon_container (arr_iter, entry_iter);
++      return FALSE;
++    }
++
++  if (!dbus_message_iter_close_container (arr_iter, entry_iter))
++    return FALSE;
++
++  return TRUE;
++}
++
++/**
++ * Closes an a{sv} after successfully appending all values.
++ *
++ * If this function fails, you must abandon iter and whatever
++ * larger data structure (message, etc.) the a{sv} was embedded in.
++ *
++ * @param iter the iterator which is appending to the message or other data structure containing the a{sv}
++ * @param arr_iter the iterator appending to the array, will be closed
++ * @returns #TRUE on success, or #FALSE if not enough memory
++ */
++dbus_bool_t
++_dbus_asv_close (DBusMessageIter *iter,
++                 DBusMessageIter *arr_iter)
++{
++  return dbus_message_iter_close_container (iter, arr_iter);
++}
++
++/**
++ * Closes an a{sv} entry after unsuccessfully appending a value.
++ * You must also abandon the a{sv} itself (for instance with
++ * _dbus_asv_abandon()), and abandon whatever larger data structure
++ * the a{sv} was embedded in.
++ *
++ * @param iter the iterator which is appending to the message or other data structure containing the a{sv}
++ * @param arr_iter the iterator appending to the array, will be closed
++ * @returns #TRUE on success, or #FALSE if not enough memory
++ */
++void
++_dbus_asv_abandon_entry (DBusMessageIter *arr_iter,
++                         DBusMessageIter *entry_iter,
++                         DBusMessageIter *var_iter)
++{
++  dbus_message_iter_abandon_container (entry_iter, var_iter);
++  dbus_message_iter_abandon_container (arr_iter, entry_iter);
++}
++
++/**
++ * Closes an a{sv} after unsuccessfully appending a value.
++ *
++ * You must also abandon whatever larger data structure (message, etc.)
++ * the a{sv} was embedded in.
++ *
++ * @param iter the iterator which is appending to the message or other data structure containing the a{sv}
++ * @param arr_iter the iterator appending to the array, will be closed
++ */
++void
++_dbus_asv_abandon (DBusMessageIter *iter,
++                   DBusMessageIter *arr_iter)
++{
++  dbus_message_iter_abandon_container (iter, arr_iter);
++}
++
++/**
++ * Create a new entry in an a{sv} (map from string to variant)
++ * with a 32-bit unsigned integer value.
++ *
++ * If this function fails, the a{sv} must be abandoned, for instance
++ * with _dbus_asv_abandon().
++ *
++ * @param arr_iter the iterator which is appending to the array
++ * @param key a UTF-8 key for the map
++ * @param value the value
++ * @returns #TRUE on success, or #FALSE if not enough memory
++ */
++dbus_bool_t
++_dbus_asv_add_uint32 (DBusMessageIter *arr_iter,
++                      const char *key,
++                      dbus_uint32_t value)
++{
++  DBusMessageIter entry_iter, var_iter;
++
++  if (!_dbus_asv_open_entry (arr_iter, &entry_iter, key,
++                             DBUS_TYPE_UINT32_AS_STRING, &var_iter))
++    return FALSE;
++
++  if (!dbus_message_iter_append_basic (&var_iter, DBUS_TYPE_UINT32,
++                                       &value))
++    {
++      _dbus_asv_abandon_entry (arr_iter, &entry_iter, &var_iter);
++      return FALSE;
++    }
++
++  if (!_dbus_asv_close_entry (arr_iter, &entry_iter, &var_iter))
++    return FALSE;
++
++  return TRUE;
++}
++
++/**
++ * Create a new entry in an a{sv} (map from string to variant)
++ * with a UTF-8 string value.
++ *
++ * If this function fails, the a{sv} must be abandoned, for instance
++ * with _dbus_asv_abandon().
++ *
++ * @param arr_iter the iterator which is appending to the array
++ * @param key a UTF-8 key for the map
++ * @param value the value
++ * @returns #TRUE on success, or #FALSE if not enough memory
++ */
++dbus_bool_t
++_dbus_asv_add_string (DBusMessageIter *arr_iter,
++                      const char *key,
++                      const char *value)
++{
++  DBusMessageIter entry_iter, var_iter;
++
++  if (!_dbus_asv_open_entry (arr_iter, &entry_iter, key,
++                             DBUS_TYPE_STRING_AS_STRING, &var_iter))
++    return FALSE;
++
++  if (!dbus_message_iter_append_basic (&var_iter, DBUS_TYPE_STRING,
++                                       &value))
++    {
++      _dbus_asv_abandon_entry (arr_iter, &entry_iter, &var_iter);
++      return FALSE;
++    }
++
++  if (!_dbus_asv_close_entry (arr_iter, &entry_iter, &var_iter))
++    return FALSE;
++
++  return TRUE;
++}
+diff --git a/dbus/dbus-asv-util.h b/dbus/dbus-asv-util.h
+new file mode 100644
+index 0000000..609f9e1
+--- /dev/null
++++ b/dbus/dbus-asv-util.h
+@@ -0,0 +1,57 @@
++/* dbus-asv-util.h - utility functions for a{sv}
++ *
++ * Copyright © 2011-2012 Nokia Corporation
++ *
++ * Licensed under the Academic Free License version 2.1
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++
++#ifndef DBUS_ASV_UTIL_H
++#define DBUS_ASV_UTIL_H
++
++#include <dbus/dbus-internals.h>
++
++DBUS_BEGIN_DECLS
++
++DBusMessage *_dbus_asv_new_method_return (DBusMessage      *message,
++                                          DBusMessageIter  *iter,
++                                          DBusMessageIter  *arr_iter);
++dbus_bool_t  _dbus_asv_close             (DBusMessageIter *iter,
++                                          DBusMessageIter *arr_iter);
++void         _dbus_asv_abandon           (DBusMessageIter *iter,
++                                          DBusMessageIter *arr_iter);
++
++dbus_bool_t  _dbus_asv_open_entry        (DBusMessageIter *arr_iter,
++                                          DBusMessageIter *entry_iter,
++                                          const char      *key,
++                                          const char      *type,
++                                          DBusMessageIter *var_iter);
++dbus_bool_t  _dbus_asv_close_entry       (DBusMessageIter *arr_iter,
++                                          DBusMessageIter *entry_iter,
++                                          DBusMessageIter *var_iter);
++void         _dbus_asv_abandon_entry     (DBusMessageIter *arr_iter,
++                                          DBusMessageIter *entry_iter,
++                                          DBusMessageIter *var_iter);
++
++dbus_bool_t  _dbus_asv_add_uint32        (DBusMessageIter *arr_iter,
++                                          const char      *key,
++                                          dbus_uint32_t    value);
++dbus_bool_t  _dbus_asv_add_string        (DBusMessageIter *arr_iter,
++                                          const char      *key,
++                                          const char      *value);
++
++#endif
+-- 
+1.8.1.5
+
diff --git a/packaging/0010-GetConnectionCredentials-add.patch b/packaging/0010-GetConnectionCredentials-add.patch
new file mode 100644
index 0000000..3359e48
--- /dev/null
+++ b/packaging/0010-GetConnectionCredentials-add.patch
@@ -0,0 +1,361 @@
+From c3fd79d34227121690d21d642ed4a0b04bce37d2 Mon Sep 17 00:00:00 2001
+From: Simon McVittie <simon.mcvittie@collabora.co.uk>
+Date: Mon, 3 Sep 2012 15:56:10 +0100
+Subject: [PATCH] GetConnectionCredentials: add
+
+The initial set of credentials is just UnixUserID and UnixProcessID.
+The rest can follow when someone is sufficiently interested to actually
+test them.
+
+Signed-off-by: Simon McVittie <simon.mcvittie@collabora.co.uk>
+Bug: https://bugs.freedesktop.org/show_bug.cgi?id=54445
+---
+ bus/driver.c               |  74 +++++++++++++++++++++++++++
+ doc/dbus-specification.xml |  91 +++++++++++++++++++++++++++++++++
+ test/dbus-daemon.c         | 122 +++++++++++++++++++++++++++++++++++++++++++++
+ 3 files changed, 287 insertions(+)
+
+diff --git a/bus/driver.c b/bus/driver.c
+index 6ccd6d6..5c4e9a2 100644
+--- a/bus/driver.c
++++ b/bus/driver.c
+@@ -1525,6 +1525,78 @@ static dbus_bool_t bus_driver_send_welcome_message (DBusConnection *connection,
+ }
+ 
+ static dbus_bool_t
++bus_driver_handle_get_connection_credentials (DBusConnection *connection,
++                                              BusTransaction *transaction,
++                                              DBusMessage    *message,
++                                              DBusError      *error)
++{
++  DBusConnection *conn;
++  DBusMessage *reply;
++  DBusMessageIter reply_iter;
++  DBusMessageIter array_iter;
++  unsigned long ulong_val;
++  const char *service;
++
++  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
++
++  reply = NULL;
++
++  conn = bus_driver_get_conn_helper (connection, message, "credentials",
++                                     &service, error);
++
++  if (conn == NULL)
++    goto failed;
++
++  reply = _dbus_asv_new_method_return (message, &reply_iter, &array_iter);
++  if (reply == NULL)
++    goto oom;
++
++  /* we can't represent > 32-bit pids */
++  if (dbus_connection_get_unix_process_id (conn, &ulong_val) &&
++      ulong_val <= _DBUS_UINT32_MAX)
++    {
++      if (!_dbus_asv_add_uint32 (&array_iter, "UnixProcessID", ulong_val))
++        goto oom;
++    }
++
++  /* we can't represent > 32-bit uids */
++  if (dbus_connection_get_unix_user (conn, &ulong_val) &&
++      ulong_val <= _DBUS_UINT32_MAX)
++    {
++      if (!_dbus_asv_add_uint32 (&array_iter, "UnixUserID", ulong_val))
++        goto oom;
++    }
++
++  if (!_dbus_asv_close (&reply_iter, &array_iter))
++    goto oom;
++
++  if (! bus_transaction_send_from_driver (transaction, connection, reply))
++    {
++      /* this time we don't want to close the iterator again, so just
++       * get rid of the message */
++      dbus_message_unref (reply);
++      reply = NULL;
++      goto oom;
++    }
++
++  return TRUE;
++
++ oom:
++  BUS_SET_OOM (error);
++
++ failed:
++  _DBUS_ASSERT_ERROR_IS_SET (error);
++
++  if (reply)
++    {
++      _dbus_asv_abandon (&reply_iter, &array_iter);
++      dbus_message_unref (reply);
++    }
++
++  return FALSE;
++}
++
++static dbus_bool_t
+ bus_driver_handle_reload_config (DBusConnection *connection,
+ 				 BusTransaction *transaction,
+ 				 DBusMessage    *message,
+@@ -1704,6 +1776,8 @@ static dbus_bool_t bus_driver_send_welcome_message (DBusConnection *connection,
+     "",
+     DBUS_TYPE_STRING_AS_STRING,
+     bus_driver_handle_get_id },
++  { "GetConnectionCredentials", "s", "a{sv}",
++    bus_driver_handle_get_connection_credentials },
+   { NULL, NULL, NULL, NULL }
+ };
+ 
+diff --git a/doc/dbus-specification.xml b/doc/dbus-specification.xml
+index b313070..e59a5e5 100644
+--- a/doc/dbus-specification.xml
++++ b/doc/dbus-specification.xml
+@@ -5560,6 +5560,97 @@
+        </para>
+       </sect3>
+ 
++      <sect3 id="bus-messages-get-connection-credentials">
++        <title><literal>org.freedesktop.DBus.GetConnectionCredentials</literal></title>
++        <para>
++          As a method:
++          <programlisting>
++            DICT&lt;STRING,VARIANT&gt; GetConnectionCredentials (in STRING bus_name)
++          </programlisting>
++          Message arguments:
++          <informaltable>
++            <tgroup cols="3">
++              <thead>
++                <row>
++                  <entry>Argument</entry>
++                  <entry>Type</entry>
++                  <entry>Description</entry>
++                </row>
++              </thead>
++              <tbody>
++                <row>
++                  <entry>0</entry>
++                  <entry>STRING</entry>
++                  <entry>Unique or well-known bus name of the connection to
++                    query, such as <literal>:12.34</literal> or
++                    <literal>com.example.tea</literal></entry>
++                </row>
++              </tbody>
++            </tgroup>
++          </informaltable>
++        Reply arguments:
++        <informaltable>
++          <tgroup cols="3">
++            <thead>
++              <row>
++                <entry>Argument</entry>
++                <entry>Type</entry>
++                <entry>Description</entry>
++              </row>
++            </thead>
++            <tbody>
++              <row>
++                <entry>0</entry>
++                <entry>DICT&lt;STRING,VARIANT&gt;</entry>
++                <entry>Credentials</entry>
++              </row>
++            </tbody>
++          </tgroup>
++        </informaltable>
++      </para>
++
++      <para>
++        Returns as many credentials as possible for the process connected to
++        the server. If unable to determine certain credentials (for instance,
++        because the process is not on the same machine as the bus daemon,
++        or because this version of the bus daemon does not support a
++        particular security framework), or if the values of those credentials
++        cannot be represented as documented here, then those credentials
++        are omitted.
++      </para>
++
++      <para>
++        Keys in the returned dictionary not containing "." are defined
++        by this specification. Bus daemon implementors supporting
++        credentials frameworks not mentioned in this document should either
++        contribute patches to this specification, or use keys containing
++        "." and starting with a reversed domain name.
++        <informaltable>
++          <tgroup cols="3">
++            <thead>
++              <row>
++                <entry>Key</entry>
++                <entry>Value type</entry>
++                <entry>Value</entry>
++              </row>
++            </thead>
++            <tbody>
++              <row>
++                <entry>UnixUserID</entry>
++                <entry>UINT32</entry>
++                <entry>The numeric Unix user ID, as defined by POSIX</entry>
++              </row>
++              <row>
++                <entry>UnixProcessID</entry>
++                <entry>UINT32</entry>
++                <entry>The numeric Unix process ID, as defined by POSIX</entry>
++              </row>
++            </tbody>
++          </tgroup>
++        </informaltable>
++       </para>
++      </sect3>
++
+       <sect3 id="bus-messages-add-match">
+         <title><literal>org.freedesktop.DBus.AddMatch</literal></title>
+         <para>
+diff --git a/test/dbus-daemon.c b/test/dbus-daemon.c
+index cc87153..5f9a6a4 100644
+--- a/test/dbus-daemon.c
++++ b/test/dbus-daemon.c
+@@ -39,6 +39,7 @@
+ #else
+ # include <signal.h>
+ # include <unistd.h>
++# include <sys/types.h>
+ #endif
+ 
+ typedef struct {
+@@ -310,6 +311,126 @@
+ }
+ 
+ static void
++pc_store (DBusPendingCall *pc,
++    void *data)
++{
++  DBusMessage **message_p = data;
++
++  *message_p = dbus_pending_call_steal_reply (pc);
++  g_assert (*message_p != NULL);
++}
++
++static void
++test_creds (Fixture *f,
++    gconstpointer context)
++{
++  const char *unique = dbus_bus_get_unique_name (f->left_conn);
++  DBusMessage *m = dbus_message_new_method_call (DBUS_SERVICE_DBUS,
++      DBUS_PATH_DBUS, DBUS_INTERFACE_DBUS, "GetConnectionCredentials");
++  DBusPendingCall *pc;
++  DBusMessageIter args_iter;
++  DBusMessageIter arr_iter;
++  DBusMessageIter pair_iter;
++  DBusMessageIter var_iter;
++  enum {
++      SEEN_UNIX_USER = 1,
++      SEEN_UNIX_PID = 2,
++      SEEN_WINDOWS_SID = 4
++  } seen = 0;
++
++  if (m == NULL)
++    g_error ("OOM");
++
++  if (!dbus_message_append_args (m,
++        DBUS_TYPE_STRING, &unique,
++        DBUS_TYPE_INVALID))
++    g_error ("OOM");
++
++  if (!dbus_connection_send_with_reply (f->left_conn, m, &pc,
++                                        DBUS_TIMEOUT_USE_DEFAULT) ||
++      pc == NULL)
++    g_error ("OOM");
++
++  dbus_message_unref (m);
++  m = NULL;
++
++  if (dbus_pending_call_get_completed (pc))
++    pc_store (pc, &m);
++  else if (!dbus_pending_call_set_notify (pc, pc_store, &m, NULL))
++    g_error ("OOM");
++
++  while (m == NULL)
++    g_main_context_iteration (NULL, TRUE);
++
++  g_assert_cmpstr (dbus_message_get_signature (m), ==, "a{sv}");
++
++  dbus_message_iter_init (m, &args_iter);
++  g_assert_cmpuint (dbus_message_iter_get_arg_type (&args_iter), ==,
++      DBUS_TYPE_ARRAY);
++  g_assert_cmpuint (dbus_message_iter_get_element_type (&args_iter), ==,
++      DBUS_TYPE_DICT_ENTRY);
++  dbus_message_iter_recurse (&args_iter, &arr_iter);
++
++  while (dbus_message_iter_get_arg_type (&arr_iter) != DBUS_TYPE_INVALID)
++    {
++      const char *name;
++
++      dbus_message_iter_recurse (&arr_iter, &pair_iter);
++      g_assert_cmpuint (dbus_message_iter_get_arg_type (&pair_iter), ==,
++          DBUS_TYPE_STRING);
++      dbus_message_iter_get_basic (&pair_iter, &name);
++      dbus_message_iter_next (&pair_iter);
++      g_assert_cmpuint (dbus_message_iter_get_arg_type (&pair_iter), ==,
++          DBUS_TYPE_VARIANT);
++      dbus_message_iter_recurse (&pair_iter, &var_iter);
++
++      if (g_strcmp0 (name, "UnixUserID") == 0)
++        {
++#ifdef G_OS_UNIX
++          guint32 u32;
++
++          g_assert_cmpuint (dbus_message_iter_get_arg_type (&var_iter), ==,
++              DBUS_TYPE_UINT32);
++          dbus_message_iter_get_basic (&var_iter, &u32);
++          g_message ("%s of this process is %u", name, u32);
++          g_assert_cmpuint (u32, ==, geteuid ());
++          seen |= SEEN_UNIX_USER;
++#else
++          g_assert_not_reached ();
++#endif
++        }
++      else if (g_strcmp0 (name, "UnixProcessID") == 0)
++        {
++#ifdef G_OS_UNIX
++          guint32 u32;
++
++          g_assert_cmpuint (dbus_message_iter_get_arg_type (&var_iter), ==,
++              DBUS_TYPE_UINT32);
++          dbus_message_iter_get_basic (&var_iter, &u32);
++          g_message ("%s of this process is %u", name, u32);
++          g_assert_cmpuint (u32, ==, getpid ());
++          seen |= SEEN_UNIX_PID;
++#else
++          g_assert_not_reached ();
++#endif
++        }
++
++      dbus_message_iter_next (&arr_iter);
++    }
++
++#ifdef G_OS_UNIX
++  g_assert (seen & SEEN_UNIX_USER);
++  g_assert (seen & SEEN_UNIX_PID);
++#endif
++
++#ifdef G_OS_WIN32
++  /* FIXME: when implemented:
++  g_assert (seen & SEEN_WINDOWS_SID);
++   */
++#endif
++}
++
++static void
+ teardown (Fixture *f,
+     gconstpointer context G_GNUC_UNUSED)
+ {
+@@ -363,6 +484,7 @@
+   g_test_add ("/echo/session", Fixture, NULL, setup, test_echo, teardown);
+   g_test_add ("/echo/limited", Fixture, &limited_config,
+       setup, test_echo, teardown);
++  g_test_add ("/creds", Fixture, NULL, setup, test_creds, teardown);
+ 
+   return g_test_run ();
+ }
+-- 
+1.8.1.5
+
diff --git a/packaging/0001-Enable-checking-of-smack-context-from-DBus-interface.patch b/packaging/0011-Store-Smack-context-of-connection.patch
similarity index 51%
rename from packaging/0001-Enable-checking-of-smack-context-from-DBus-interface.patch
rename to packaging/0011-Store-Smack-context-of-connection.patch
index f91e5ff..84642f6 100644
--- a/packaging/0001-Enable-checking-of-smack-context-from-DBus-interface.patch
+++ b/packaging/0011-Store-Smack-context-of-connection.patch
@@ -1,17 +1,19 @@
-From 225a2405369228dcd38d67e13801e4251bc3872e Mon Sep 17 00:00:00 2001
+From 3338dec2a6c43c85f17271cfda2c5b7f478554ed Mon Sep 17 00:00:00 2001
 From: Brian McGillion <brian.mcgillion@intel.com>
-Date: Mon, 6 Feb 2012 18:46:05 +0200
-Subject: [PATCH 1/2] Enable checking of smack context from DBus interface
+Date: Thu, 18 Oct 2012 17:52:26 +0300
+Subject: [PATCH] Store Smack context of connection
 
+Signed-off-by: Brian McGillion <brian.mcgillion@intel.com>
 ---
- bus/Makefile.am          |    4 ++
- bus/driver.c             |    6 ++
- bus/smack.c              |  132 ++++++++++++++++++++++++++++++++++++++++++++++
- bus/smack.h              |   36 +++++++++++++
- cmake/CMakeLists.txt     |    3 +
- cmake/bus/CMakeLists.txt |    4 +-
- configure.ac             |   17 +++++-
- 7 files changed, 199 insertions(+), 3 deletions(-)
+ bus/Makefile.am          |  4 +++
+ bus/connection.c         | 26 ++++++++++++++++
+ bus/connection.h         |  1 +
+ bus/smack.c              | 78 ++++++++++++++++++++++++++++++++++++++++++++++++
+ bus/smack.h              | 37 +++++++++++++++++++++++
+ cmake/CMakeLists.txt     |  3 ++
+ cmake/bus/CMakeLists.txt |  4 ++-
+ configure.ac             | 14 +++++++--
+ 8 files changed, 164 insertions(+), 3 deletions(-)
  create mode 100644 bus/smack.c
  create mode 100644 bus/smack.h
 
@@ -44,47 +46,100 @@ index 6cbc09a..7f63d86 100644
  	stats.c					\
  	stats.h					\
  	test.c					\
-diff --git a/bus/driver.c b/bus/driver.c
-index 574e0f3..c6298d7 100644
---- a/bus/driver.c
-+++ b/bus/driver.c
+diff --git a/bus/connection.c b/bus/connection.c
+index d69758c..07c711a 100644
+--- a/bus/connection.c
++++ b/bus/connection.c
 @@ -30,6 +30,7 @@
- #include "services.h"
- #include "selinux.h"
  #include "signals.h"
+ #include "expirelist.h"
+ #include "selinux.h"
 +#include "smack.h"
- #include "stats.h"
- #include "utils.h"
- #include <dbus/dbus-string.h>
-@@ -38,6 +39,7 @@
- #include <dbus/dbus-marshal-recursive.h>
- #include <string.h>
+ #include <dbus/dbus-list.h>
+ #include <dbus/dbus-hash.h>
+ #include <dbus/dbus-timeout.h>
+@@ -98,6 +99,8 @@ struct BusConnections
+   long connection_tv_usec; /**< Time when we connected (microsec component) */
+   int stamp;               /**< connections->stamp last time we were traversed */
  
-+
- static dbus_bool_t bus_driver_send_welcome_message (DBusConnection *connection,
-                                                     DBusMessage    *hello_message,
-                                                     BusTransaction *transaction,
-@@ -1736,6 +1738,10 @@ static const MessageHandler dbus_message_handlers[] = {
-     "",
-     DBUS_TYPE_STRING_AS_STRING,
-     bus_driver_handle_get_id },
-+  { "GetConnectionSmackContext",
-+    DBUS_TYPE_STRING_AS_STRING,
-+    DBUS_TYPE_STRING_AS_STRING,
-+    bus_smack_handle_get_connection_context },
-   { NULL, NULL, NULL, NULL }
- };
++  char *smack_label;
++
+ #ifdef DBUS_ENABLE_STATS
+   int peak_match_rules;
+   int peak_bus_names;
+@@ -409,6 +412,9 @@ static void bus_connection_drop_pending_replies (BusConnections  *connections,
+   
+   dbus_free (d->name);
+   
++  if (d->smack_label)
++    bus_smack_label_free (d->smack_label);
++
+   dbus_free (d);
+ }
+ 
+@@ -626,6 +632,10 @@ static void bus_connection_drop_pending_replies (BusConnections  *connections,
+   dbus_error_init (&error);
+   d->selinux_id = bus_selinux_init_connection_id (connection,
+                                                   &error);
++
++  if (!dbus_error_is_set (&error))
++    d->smack_label = bus_smack_get_label(connection, &error);
++
+   if (dbus_error_is_set (&error))
+     {
+       /* This is a bit bogus because we pretend all errors
+@@ -723,6 +733,10 @@ static void bus_connection_drop_pending_replies (BusConnections  *connections,
+         bus_selinux_id_unref (d->selinux_id);
+       d->selinux_id = NULL;
+       
++      if (d->smack_label)
++        bus_smack_label_free (d->smack_label);
++      d->smack_label = NULL;
++
+       if (!dbus_connection_set_watch_functions (connection,
+                                                 NULL, NULL, NULL,
+                                                 connection,
+@@ -1107,6 +1121,18 @@ static void bus_connection_drop_pending_replies (BusConnections  *connections,
+   return d->selinux_id;
+ }
  
++const char*
++bus_connection_get_smack_label (DBusConnection *connection)
++{
++  BusConnectionData *d;
++
++  d = BUS_CONNECTION_DATA (connection);
++
++  _dbus_assert (d != NULL);
++
++  return d->smack_label;
++}
++
+ /**
+  * Checks whether the connection is registered with the message bus.
+  *
+diff --git a/bus/connection.h b/bus/connection.h
+index c936021..1532074 100644
+--- a/bus/connection.h
++++ b/bus/connection.h
+@@ -52,6 +52,7 @@ void            bus_connections_foreach_active    (BusConnections
+ BusMatchmaker*  bus_connection_get_matchmaker     (DBusConnection               *connection);
+ const char *    bus_connection_get_loginfo        (DBusConnection        *connection);
+ BusSELinuxID*   bus_connection_get_selinux_id     (DBusConnection               *connection);
++const char *    bus_connection_get_smack_label    (DBusConnection               *connection);
+ dbus_bool_t     bus_connections_check_limits      (BusConnections               *connections,
+                                                    DBusConnection               *requesting_completion,
+                                                    DBusError                    *error);
 diff --git a/bus/smack.c b/bus/smack.c
 new file mode 100644
-index 0000000..b8542c2
+index 0000000..f487c0c
 --- /dev/null
 +++ b/bus/smack.c
-@@ -0,0 +1,132 @@
+@@ -0,0 +1,78 @@
 +/* smack.c - Provide interface to query smack context
 + *
 + * Author: Brian McGillion <brian.mcgillion@intel.com>
-+ * Copyright © 2011 Intel Corporation
++ * Copyright © 2012 Intel Corporation
 + *
 + * Licensed under the Academic Free License version 2.1
 + *
@@ -113,116 +168,62 @@ index 0000000..b8542c2
 +#include "services.h"
 +#include "utils.h"
 +
++#include <stdlib.h>
++
++#ifdef HAVE_ERRNO_H
++#include <errno.h>
++#endif
 +#ifdef DBUS_ENABLE_SMACK
 +#include <sys/smack.h>
 +#endif
 +
-+#ifdef DBUS_ENABLE_SMACK
-+static char *
-+bus_smack_get_label (DBusConnection *connection)
++char *
++bus_smack_get_label (DBusConnection *connection, DBusError *error)
 +{
++#ifdef DBUS_ENABLE_SMACK
 +  char *label;
 +  int sock_fd;
 +
 +  if (!dbus_connection_get_socket(connection, &sock_fd))
-+    return NULL;
-+
-+  if (smack_new_label_from_socket(sock_fd, &label) < 0)
-+    return NULL;
-+  return label;
-+}
-+#endif
-+
-+dbus_bool_t
-+bus_smack_handle_get_connection_context (DBusConnection *connection,
-+                                         BusTransaction *transaction,
-+                                         DBusMessage    *message,
-+                                         DBusError      *error)
-+{
-+#ifdef DBUS_ENABLE_SMACK
-+  const char *remote_end = NULL;
-+  BusRegistry *registry;
-+  DBusString remote_end_str;
-+  BusService *service;
-+  DBusConnection *remote_connection;
-+  DBusMessage *reply = NULL;
-+  char *label;
-+
-+  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
-+
-+  registry = bus_connection_get_registry (connection);
-+
-+  if (!dbus_message_get_args (message, error, DBUS_TYPE_STRING, &remote_end,
-+                              DBUS_TYPE_INVALID))
-+    return FALSE;
-+
-+  _dbus_verbose ("asked for label of connection %s\n", remote_end);
-+
-+  _dbus_string_init_const (&remote_end_str, remote_end);
-+
-+  service = bus_registry_lookup (registry, &remote_end_str);
-+  if (service == NULL)
 +    {
-+      dbus_set_error (error, DBUS_ERROR_NAME_HAS_NO_OWNER,
-+                      "Bus name '%s' has no owner", remote_end);
-+      return FALSE;
++      dbus_set_error (error, DBUS_ERROR_FAILED,
++                      "Failed to get the socket descriptor of the connection.\n");
++      _dbus_verbose ("Failed to get socket descriptor of connection for Smack check.%s\n");
++      return NULL;
 +    }
 +
-+  remote_connection = bus_service_get_primary_owners_connection (service);
-+  if (remote_connection == NULL)
-+    goto oom;
-+
-+  reply = dbus_message_new_method_return (message);
-+  if (reply == NULL)
-+    goto oom;
-+
-+  label = bus_smack_get_label (remote_connection);
-+  if (label == NULL)
++  /* retrieve an ascii, null-terminated string that defines the Smack context of the connected socket */
++  if (smack_new_label_from_socket(sock_fd, &label) < 0)
 +    {
 +      dbus_set_error (error, DBUS_ERROR_FAILED,
-+                      "Failed to get the socket fd of the connection",
-+                      remote_end);
-+      goto err;
++                      "Failed to read the Smack context from the connection: %s.\n",
++                      _dbus_strerror (errno));
++      _dbus_verbose ("Failed to read the Smack context from the connection: %s.\n",
++                     _dbus_strerror (errno));
++      return NULL;
 +    }
-+
-+  if (!dbus_message_append_args (reply, DBUS_TYPE_STRING,
-+                                 &label, DBUS_TYPE_INVALID))
-+    goto oom;
-+
-+  if (!bus_transaction_send_from_driver (transaction, connection, reply))
-+    goto oom;
-+
-+  dbus_message_unref (reply);
-+  dbus_free(label);
-+
-+  return TRUE;
-+
-+oom:
-+  BUS_SET_OOM (error);
-+
-+err:
-+  if (reply != NULL)
-+    dbus_message_unref (reply);
-+
-+  dbus_free(label);
-+
-+  return FALSE;
++  return label;
 +#else
-+  dbus_set_error (error, DBUS_ERROR_NOT_SUPPORTED,
-+                  "SMACK support is not enabled");
-+  return FALSE;
++  return NULL;
 +#endif
 +}
++
++void
++bus_smack_label_free (char *label)
++{
++  if (label)
++    free (label);
++}
 diff --git a/bus/smack.h b/bus/smack.h
 new file mode 100644
-index 0000000..04a4a2a
+index 0000000..51773b9
 --- /dev/null
 +++ b/bus/smack.h
-@@ -0,0 +1,36 @@
+@@ -0,0 +1,37 @@
 +/* smack.h - Provide interface to query smack context
 + *
 + * Author: Brian McGillion <brian.mcgillion@intel.com>
-+ * Copyright © 2011 Intel Corporation
++ * Copyright © 2012 Intel Corporation
 + *
 + * Based on example from Stats interface
 + *
@@ -249,26 +250,27 @@ index 0000000..04a4a2a
 +
 +#include "bus.h"
 +
-+dbus_bool_t bus_smack_handle_get_connection_context (DBusConnection *connection,
-+                                                     BusTransaction *transaction,
-+                                                     DBusMessage    *message,
-+                                                     DBusError      *error);
++char *
++bus_smack_get_label (DBusConnection *connection, DBusError *error);
++
++void
++bus_smack_label_free (char *label);
 +
 +#endif // SMACK_H
 diff --git a/cmake/CMakeLists.txt b/cmake/CMakeLists.txt
-index 72c4231..c434be4 100644
+index 52a48fd..ea5c3d0 100644
 --- a/cmake/CMakeLists.txt
 +++ b/cmake/CMakeLists.txt
-@@ -102,6 +102,8 @@ option (DBUS_ENABLE_STATS "enable bus daemon usage statistics" OFF)
+@@ -94,6 +94,8 @@ option (DBUS_ENABLE_STATS "enable bus daemon usage statistics" OFF)
  
  option (DBUS_ENABLE_STATS "enable bus daemon usage statistics" OFF)
  
 +option (DBUS_ENABLE_SMACK "enable smack checks in the daemon" OFF)
 +
- # analogous to AC_USE_SYSTEM_EXTENSIONS in configure.ac
- add_definitions(-D_POSIX_C_SOURCE=199309L -D_GNU_SOURCE)
- 
-@@ -572,6 +574,7 @@ message("        Building bus stats API:   ${DBUS_ENABLE_STATS}                "
+ if (DBUS_USE_EXPAT)
+     find_package(LibExpat)
+ else ()
+@@ -564,6 +566,7 @@ message("        Building bus stats API:   ${DBUS_ENABLE_STATS}                "
  message("        installing system libs:   ${DBUS_INSTALL_SYSTEM_LIBS}         ")
  #message("        Building SELinux support: ${have_selinux}                     ")
  #message("        Building dnotify support: ${have_dnotify}                     ")
@@ -277,25 +279,25 @@ index 72c4231..c434be4 100644
  message("        Building XML docs:        ${DBUS_ENABLE_XML_DOCS}             ")
  #message("        Gettext libs (empty OK):  ${INTLLIBS}                         ")
 diff --git a/cmake/bus/CMakeLists.txt b/cmake/bus/CMakeLists.txt
-index 1db519f..3fe36d1 100644
+index faf9a8e..68b47ce 100644
 --- a/cmake/bus/CMakeLists.txt
 +++ b/cmake/bus/CMakeLists.txt
-@@ -70,7 +70,9 @@ set (BUS_SOURCES
+@@ -65,7 +65,9 @@ set (BUS_SOURCES
+ 	${BUS_DIR}/services.c				
+ 	${BUS_DIR}/services.h				
+ 	${BUS_DIR}/signals.c				
+-	${BUS_DIR}/signals.h				
++	${BUS_DIR}/signals.h
++	${BUS_DIR}/smack.c
++        ${BUS_DIR}/smack.h
  	${BUS_DIR}/test.c					
  	${BUS_DIR}/test.h					
  	${BUS_DIR}/utils.c					
--	${BUS_DIR}/utils.h					
-+	${BUS_DIR}/utils.h
-+	${BUS_DIR}/smack.c
-+	${BUS_DIR}/smack.h
- 	${XML_SOURCES}
- 	${DIR_WATCH_SOURCE}
- )
 diff --git a/configure.ac b/configure.ac
-index c6eb296..495697c 100644
+index e2c9bdf..7e308c5 100644
 --- a/configure.ac
 +++ b/configure.ac
-@@ -186,6 +186,9 @@ if test "x$enable_embedded_tests" = xyes; then
+@@ -206,6 +206,9 @@ if test "x$enable_embedded_tests" = xyes; then
        [Define to build test code into the library and binaries])
  fi
  
@@ -305,7 +307,7 @@ index c6eb296..495697c 100644
  # DBUS_ENABLE_MODULAR_TESTS controls tests that work based on public API.
  # These use GTest, from GLib, because life's too short. They're enabled by
  # default (unless you don't have GLib), because they don't bloat the library
-@@ -875,8 +878,6 @@ fi
+@@ -901,8 +904,6 @@ fi
  # unix:path=/foo or unix:abstract=/foo
  AC_SUBST(DBUS_PATH_OR_ABSTRACT)
  
@@ -314,32 +316,29 @@ index c6eb296..495697c 100644
  #### Sort out XML library
  
  # see what we have
-@@ -1612,6 +1613,17 @@ if test "x$enable_stats" = xyes; then
+@@ -1756,6 +1757,14 @@ if test "x$enable_stats" = xyes; then
      [Define to enable bus daemon usage statistics])
  fi
  
 +#enable smack label support
-+AC_ARG_ENABLE([smack], [AS_HELP_STRING([--enable-smack], [enable SMACK security checks])], [], [enable_smack=no])
++AC_ARG_ENABLE([smack], [AS_HELP_STRING([--enable-smack], [enable Smack security checks])], [], [enable_smack=no])
 +if test "x$enable_smack" = xyes; then
 +  PKG_CHECK_MODULES([LIBSMACK], [libsmack >= 1.0],
-+     [AC_DEFINE([DBUS_ENABLE_SMACK], [1], [Define to enable SMACK security features])],
++     [AC_DEFINE([DBUS_ENABLE_SMACK], [1], [Define to enable Smack security features])],
 +     [AC_MSG_ERROR([libsmack is required to enable smack support])])
 +fi
 +
-+AC_SUBST([LIBSMACK_CFLAGS])
-+AC_SUBST([LIBSMACK_LIBS])
-+
  AC_CONFIG_FILES([
  Doxyfile
  dbus/versioninfo.rc
-@@ -1689,6 +1701,7 @@ echo "
+@@ -1834,6 +1843,7 @@ echo "
          Building checks:          ${enable_checks}
          Building bus stats API:   ${enable_stats}
          Building SELinux support: ${have_selinux}
-+	Building SMACK support:   ${enable_smack}
++        Building Smack support:   ${enable_smack}
          Building inotify support: ${have_inotify}
          Building dnotify support: ${have_dnotify}
          Building kqueue support:  ${have_kqueue}
 -- 
-1.7.5.4
+1.8.1.5
 
diff --git a/packaging/0012-Return-Smack-context-with-connection-credentials.patch b/packaging/0012-Return-Smack-context-with-connection-credentials.patch
new file mode 100644
index 0000000..6daeecf
--- /dev/null
+++ b/packaging/0012-Return-Smack-context-with-connection-credentials.patch
@@ -0,0 +1,67 @@
+From a186647b72b94687b102ed6b507750b0ce7a8e49 Mon Sep 17 00:00:00 2001
+From: Brian McGillion <brian.mcgillion@intel.com>
+Date: Thu, 18 Oct 2012 17:53:46 +0300
+Subject: [PATCH] Return Smack context with connection credentials
+
+Signed-off-by: Brian McGillion <brian.mcgillion@intel.com>
+---
+ bus/driver.c               | 9 +++++++++
+ doc/dbus-specification.xml | 8 ++++++++
+ 2 files changed, 17 insertions(+)
+
+diff --git a/bus/driver.c b/bus/driver.c
+index 5c4e9a2..ee5ea88 100644
+--- a/bus/driver.c
++++ b/bus/driver.c
+@@ -30,6 +30,7 @@
+ #include "services.h"
+ #include "selinux.h"
+ #include "signals.h"
++#include "smack.h"
+ #include "stats.h"
+ #include "utils.h"
+ 
+@@ -1536,6 +1537,7 @@ static dbus_bool_t bus_driver_send_welcome_message (DBusConnection *connection,
+   DBusMessageIter array_iter;
+   unsigned long ulong_val;
+   const char *service;
++  char *smack_ctx;
+ 
+   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
+ 
+@@ -1567,6 +1569,13 @@ static dbus_bool_t bus_driver_send_welcome_message (DBusConnection *connection,
+         goto oom;
+     }
+ 
++  smack_ctx = bus_connection_get_smack_label (conn);
++  if (smack_ctx)
++    {
++      if (!_dbus_asv_add_string(&array_iter, "SmackContext", smack_ctx))
++        goto oom;
++    }
++
+   if (!_dbus_asv_close (&reply_iter, &array_iter))
+     goto oom;
+ 
+diff --git a/doc/dbus-specification.xml b/doc/dbus-specification.xml
+index e59a5e5..108bd5a 100644
+--- a/doc/dbus-specification.xml
++++ b/doc/dbus-specification.xml
+@@ -5645,6 +5645,14 @@
+                 <entry>UINT32</entry>
+                 <entry>The numeric Unix process ID, as defined by POSIX</entry>
+               </row>
++	      <row>
++		<entry>SmackContext</entry>
++		<entry>STRING</entry>
++		<entry>This is a ascii string that defines the Smack context
++		of the process that owns the connection.  Smack is a Manditory
++		Access Control framework, that is part of the Linux kernel.
++		</entry>
++	      </row>
+             </tbody>
+           </tgroup>
+         </informaltable>
+-- 
+1.8.1.5
+
diff --git a/packaging/0002-Enforce-smack-policy-from-conf-file.patch b/packaging/0013-Enforce-Smack-policy-from-conf-file.patch
similarity index 59%
rename from packaging/0002-Enforce-smack-policy-from-conf-file.patch
rename to packaging/0013-Enforce-Smack-policy-from-conf-file.patch
index 0043c6d..079874d 100644
--- a/packaging/0002-Enforce-smack-policy-from-conf-file.patch
+++ b/packaging/0013-Enforce-Smack-policy-from-conf-file.patch
@@ -1,51 +1,51 @@
-From d49d9e8e8472280753f95ec5a3b832c493d4305a Mon Sep 17 00:00:00 2001
+From 55c0dda111dc5ce1ce5c5a63e4920d546e1f0e43 Mon Sep 17 00:00:00 2001
 From: Brian McGillion <brian.mcgillion@intel.com>
-Date: Mon, 6 Feb 2012 18:48:30 +0200
-Subject: [PATCH 2/2] Enforce smack policy from conf file
+Date: Thu, 18 Oct 2012 18:13:48 +0300
+Subject: [PATCH] Enforce Smack policy from conf file
 
+Signed-off-by: Brian McGillion <brian.mcgillion@intel.com>
 ---
- bus/config-parser.c |   38 ++++++++++----
- bus/policy.c        |  141 ++++++++++++++++++++++++++++++++++++++++++++++++---
- bus/policy.h        |    3 +
- bus/smack.c         |  111 ++++++++++++++++++++++++++++++++++++++++
- bus/smack.h         |    4 ++
- 5 files changed, 278 insertions(+), 19 deletions(-)
+ bus/config-parser.c |  35 ++++++++++-----
+ bus/policy.c        | 125 ++++++++++++++++++++++++++++++++++++++++++++++++++++
+ bus/policy.h        |   3 ++
+ bus/smack.c         | 104 +++++++++++++++++++++++++++++++++++++++++++
+ bus/smack.h         |  11 +++--
+ 5 files changed, 264 insertions(+), 14 deletions(-)
 
 diff --git a/bus/config-parser.c b/bus/config-parser.c
-index c636707..c9bcb04 100644
+index 07e8fbb..8601cd4 100644
 --- a/bus/config-parser.c
 +++ b/bus/config-parser.c
-@@ -43,6 +43,7 @@ typedef enum
+@@ -43,7 +43,8 @@
    POLICY_MANDATORY,
    POLICY_USER,
    POLICY_GROUP,
-+  POLICY_SMACK,
-   POLICY_CONSOLE
+-  POLICY_CONSOLE
++  POLICY_CONSOLE,
++  POLICY_SMACK
  } PolicyType;
  
-@@ -64,7 +65,11 @@ typedef struct
+ typedef struct
+@@ -64,7 +65,8 @@
      struct
      {
        PolicyType type;
 -      unsigned long gid_uid_or_at_console;      
-+      union
-+      {
-+        unsigned long gid_uid_or_at_console;
-+        char *smack_label;
-+      };
++      unsigned long gid_uid_or_at_console;
++      char *smack_label;
      } policy;
  
      struct
-@@ -150,6 +155,8 @@ element_free (Element *e)
+@@ -150,6 +152,8 @@ struct BusConfigParser
  {
    if (e->type == ELEMENT_LIMIT)
      dbus_free (e->d.limit.name);
 +  else if (e->type == ELEMENT_POLICY && e->d.policy.type == POLICY_SMACK)
-+      dbus_free (e->d.policy.smack_label);
++    dbus_free (e->d.policy.smack_label);
    
    dbus_free (e);
  }
-@@ -972,6 +979,7 @@ start_busconfig_child (BusConfigParser   *parser,
+@@ -972,6 +976,7 @@ struct BusConfigParser
        const char *user;
        const char *group;
        const char *at_console;
@@ -53,12 +53,11 @@ index c636707..c9bcb04 100644
  
        if ((e = push_element (parser, ELEMENT_POLICY)) == NULL)
          {
-@@ -988,20 +996,16 @@ start_busconfig_child (BusConfigParser   *parser,
-                               "context", &context,
+@@ -989,19 +994,15 @@ struct BusConfigParser
                                "user", &user,
                                "group", &group,
-+                              "smack", &smack,
                                "at_console", &at_console,
++                              "smack", &smack,
                                NULL))
          return FALSE;
  
@@ -70,17 +69,17 @@ index c636707..c9bcb04 100644
 -           (group && at_console) ||
 -          !(context || user || group || at_console))
 +      if (((context != NULL) + (user != NULL) + (group != NULL) +
-+          (smack != NULL) + (at_console != NULL)) != 1)
++           (smack != NULL) + (at_console != NULL)) != 1)
          {
            dbus_set_error (error, DBUS_ERROR_FAILED,
 -                          "<policy> element must have exactly one of (context|user|group|at_console) attributes");
-+                          "<policy> element must have exactly one of (context|user|group|smack|at_console) attributes");
++                          "<policy> element must have exactly one of (context|user|group|at_console|smack) attributes");
            return FALSE;
          }
  
-@@ -1047,6 +1051,16 @@ start_busconfig_child (BusConfigParser   *parser,
-             _dbus_warn ("Unknown group \"%s\" in message bus configuration file\n",
-                         group);          
+@@ -1065,6 +1066,16 @@ struct BusConfigParser
+                return FALSE;
+              }
          }
 +      else if (smack != NULL)
 +        {
@@ -92,24 +91,22 @@ index c636707..c9bcb04 100644
 +              return FALSE;
 +            }
 +        }
-       else if (at_console != NULL)
+       else
          {
-            dbus_bool_t t;
-@@ -1616,8 +1630,10 @@ append_rule_from_element (BusConfigParser   *parser,
-                                              rule))
+           _dbus_assert_not_reached ("all <policy> attributes null and we didn't set error");
+@@ -1638,6 +1649,10 @@ struct BusConfigParser
+                                                rule))
              goto nomem;
            break;
--        
--
 +        case POLICY_SMACK:
 +          if (!bus_policy_append_smack_rule (parser->policy, pe->d.policy.smack_label, rule))
 +            goto nomem;
 +          break;
-         case POLICY_CONSOLE:
-           if (!bus_policy_append_console_rule (parser->policy, pe->d.policy.gid_uid_or_at_console,
-                                                rule))
+         }
+  
+       bus_policy_rule_unref (rule);
 diff --git a/bus/policy.c b/bus/policy.c
-index 34e8446..1ae7440 100644
+index 379cea9..ea7bffe 100644
 --- a/bus/policy.c
 +++ b/bus/policy.c
 @@ -26,6 +26,7 @@
@@ -120,27 +117,15 @@ index 34e8446..1ae7440 100644
  #include <dbus/dbus-list.h>
  #include <dbus/dbus-hash.h>
  #include <dbus/dbus-internals.h>
-@@ -126,12 +127,13 @@ struct BusPolicy
- {
-   int refcount;
- 
--  DBusList *default_rules;         /**< Default policy rules */
--  DBusList *mandatory_rules;       /**< Mandatory policy rules */
--  DBusHashTable *rules_by_uid;     /**< per-UID policy rules */
--  DBusHashTable *rules_by_gid;     /**< per-GID policy rules */
--  DBusList *at_console_true_rules; /**< console user policy rules where at_console="true"*/
--  DBusList *at_console_false_rules; /**< console user policy rules where at_console="false"*/
-+  DBusList *default_rules;             /**< Default policy rules */
-+  DBusList *mandatory_rules;           /**< Mandatory policy rules */
-+  DBusHashTable *rules_by_uid;         /**< per-UID policy rules */
-+  DBusHashTable *rules_by_gid;         /**< per-GID policy rules */
-+  DBusHashTable *rules_by_smack_label; /**< per-SMACK label policy rules */
-+  DBusList *at_console_true_rules;     /**< console user policy rules where at_console="true"*/
-+  DBusList *at_console_false_rules;    /**< console user policy rules where at_console="false"*/
+@@ -132,6 +133,7 @@ struct BusPolicy
+   DBusHashTable *rules_by_gid;     /**< per-GID policy rules */
+   DBusList *at_console_true_rules; /**< console user policy rules where at_console="true"*/
+   DBusList *at_console_false_rules; /**< console user policy rules where at_console="false"*/
++  DBusHashTable *rules_by_smack_label; /**< per-Smack label policy rules or NULL if disabled*/
  };
  
  static void
-@@ -181,6 +183,14 @@ bus_policy_new (void)
+@@ -181,6 +183,14 @@ struct BusPolicy
    if (policy->rules_by_gid == NULL)
      goto failed;
  
@@ -155,37 +140,36 @@ index 34e8446..1ae7440 100644
    return policy;
    
   failed:
-@@ -230,7 +240,13 @@ bus_policy_unref (BusPolicy *policy)
+@@ -230,6 +240,12 @@ struct BusPolicy
            _dbus_hash_table_unref (policy->rules_by_gid);
            policy->rules_by_gid = NULL;
          }
--      
 +
 +      if (policy->rules_by_smack_label)
 +        {
 +          _dbus_hash_table_unref (policy->rules_by_smack_label);
 +          policy->rules_by_smack_label = NULL;
 +        }
-+
+       
        dbus_free (policy);
      }
- }
-@@ -356,6 +372,24 @@ bus_policy_create_client_policy (BusPolicy      *policy,
+@@ -356,6 +372,25 @@ struct BusPolicy
          }
      }
  
 +  if (policy->rules_by_smack_label &&
 +      _dbus_hash_table_get_n_entries (policy->rules_by_smack_label) > 0)
 +    {
-+      DBusList **list;
++      DBusList *list = NULL;
 +      dbus_bool_t nomem_err = FALSE;
 +
-+      list = bus_smack_generate_allowed_list(connection, policy->rules_by_smack_label, &nomem_err);
++      if (!bus_smack_generate_allowed_list (connection, policy->rules_by_smack_label, &list))
++        goto nomem;
 +
 +      if (list != NULL)
 +        {
 +          nomem_err = !add_list_to_client (list, client);
-+          _dbus_list_clear (list);
++          _dbus_list_clear (&list);
 +        }
 +
 +      if (nomem_err)
@@ -195,19 +179,22 @@ index 34e8446..1ae7440 100644
    if (!add_list_to_client (&policy->mandatory_rules,
                             client))
      goto nomem;
-@@ -576,6 +610,66 @@ bus_policy_append_group_rule (BusPolicy      *policy,
-   return TRUE;
+@@ -598,6 +633,67 @@ struct BusPolicy
+ 
  }
  
-+#ifdef DBUS_ENABLE_SMACK
++/*
++ * Search table for a list that is referenced by key.
++ * If the corresponding entry does not exist create it.
++ */
 +static DBusList **
-+get_list_string (DBusHashTable *table,
-+                 const char *key)
++ensure_list_for_key (DBusHashTable *table,
++                     const char *key)
 +{
 +  DBusList **list;
 +
 +  if (key == NULL)
-+      return NULL;
++    return NULL;
 +
 +  list = _dbus_hash_table_lookup_string (table, key);
 +
@@ -236,7 +223,6 @@ index 34e8446..1ae7440 100644
 +
 +  return list;
 +}
-+#endif
 +
 +dbus_bool_t
 +bus_policy_append_smack_rule (BusPolicy      *policy,
@@ -246,7 +232,7 @@ index 34e8446..1ae7440 100644
 +#ifdef DBUS_ENABLE_SMACK
 +  DBusList **list;
 +
-+  list = get_list_string (policy->rules_by_smack_label, label);
++  list = ensure_list_for_key (policy->rules_by_smack_label, label);
 +  if (list == NULL)
 +    return FALSE;
 +
@@ -255,18 +241,16 @@ index 34e8446..1ae7440 100644
 +
 +  bus_policy_rule_ref (rule);
 +#endif
-+
 +  return TRUE;
 +}
 +
- dbus_bool_t
- bus_policy_append_console_rule (BusPolicy      *policy,
-                                 dbus_bool_t     at_console,
-@@ -653,6 +747,31 @@ merge_id_hash (DBusHashTable *dest,
+ static dbus_bool_t
+ append_copy_of_policy_list (DBusList **list,
+                             DBusList **to_append)
+@@ -653,6 +749,29 @@ struct BusPolicy
    return TRUE;
  }
  
-+#ifdef DBUS_ENABLE_SMACK
 +static dbus_bool_t
 +merge_string_hash (DBusHashTable *dest,
 +                   DBusHashTable *to_absorb)
@@ -278,7 +262,7 @@ index 34e8446..1ae7440 100644
 +    {
 +      const char *absorb_label = _dbus_hash_iter_get_string_key(&iter);
 +      DBusList **list = _dbus_hash_iter_get_value (&iter);
-+      DBusList **target = get_list_string (dest, absorb_label);
++      DBusList **target = ensure_list_for_key (dest, absorb_label);
 +
 +      if (target == NULL)
 +        return FALSE;
@@ -289,12 +273,11 @@ index 34e8446..1ae7440 100644
 +
 +  return TRUE;
 +}
-+#endif
 +
  dbus_bool_t
  bus_policy_merge (BusPolicy *policy,
                    BusPolicy *to_absorb)
-@@ -685,6 +804,12 @@ bus_policy_merge (BusPolicy *policy,
+@@ -685,6 +804,12 @@ struct BusPolicy
                        to_absorb->rules_by_gid))
      return FALSE;
  
@@ -307,54 +290,35 @@ index 34e8446..1ae7440 100644
    return TRUE;
  }
  
-@@ -1247,7 +1372,7 @@ bus_client_policy_check_can_own (BusClientPolicy  *policy,
- {
-   DBusList *link;
-   dbus_bool_t allowed;
--  
-+
-   /* policy->rules is in the order the rules appeared
-    * in the config file, i.e. last rule that applies wins
-    */
 diff --git a/bus/policy.h b/bus/policy.h
-index 1782dbf..2791f7a 100644
+index 3ff6f48..f498102 100644
 --- a/bus/policy.h
 +++ b/bus/policy.h
-@@ -128,6 +128,9 @@ dbus_bool_t      bus_policy_append_user_rule      (BusPolicy        *policy,
- dbus_bool_t      bus_policy_append_group_rule     (BusPolicy        *policy,
-                                                    dbus_gid_t        gid,
+@@ -133,6 +133,9 @@ dbus_bool_t      bus_policy_append_group_rule     (BusPolicy        *policy,
+ dbus_bool_t      bus_policy_append_console_rule   (BusPolicy        *policy,
+                                                    dbus_bool_t        at_console,
                                                     BusPolicyRule    *rule);
 +dbus_bool_t      bus_policy_append_smack_rule     (BusPolicy        *policy,
 +                                                   const char       *label,
 +                                                   BusPolicyRule    *rule);
- dbus_bool_t      bus_policy_append_console_rule   (BusPolicy        *policy,
-                                                    dbus_bool_t        at_console,
-                                                    BusPolicyRule    *rule);
+ 
+ dbus_bool_t      bus_policy_merge                 (BusPolicy        *policy,
+                                                    BusPolicy        *to_absorb);
 diff --git a/bus/smack.c b/bus/smack.c
-index b8542c2..d4546a3 100644
+index f487c0c..5e67ebd 100644
 --- a/bus/smack.c
 +++ b/bus/smack.c
-@@ -29,11 +29,17 @@
+@@ -29,6 +29,7 @@
  #include "connection.h"
  #include "services.h"
  #include "utils.h"
 +#include "policy.h"
  
- #ifdef DBUS_ENABLE_SMACK
- #include <sys/smack.h>
- #endif
+ #include <stdlib.h>
  
-+#define SMACK_WRITE "W"
-+#define SMACK_READ "R"
-+#define SMACK_READ_WRITE "RW"
-+
-+
- #ifdef DBUS_ENABLE_SMACK
- static char *
- bus_smack_get_label (DBusConnection *connection)
-@@ -130,3 +136,108 @@ err:
-   return FALSE;
- #endif
+@@ -76,3 +77,106 @@
+   if (label)
+     free (label);
  }
 +
 +#ifdef DBUS_ENABLE_SMACK
@@ -366,34 +330,33 @@ index b8542c2..d4546a3 100644
 +}
 +#endif
 +
-+
 +/**
 + * Calculate the list of rules that apply to a connection.
 + *
 + * @param connection The inbound conenction
 + * @param rules_by_smack_label The table of object labels -> rules mapping
-+ * @param nomem_err (out) If a nomem situation is encountered this value is set to TRUE.
-+ * @returns the list of permitted rules if it exists and no errors were encountered otherwise NULL.
++ * @param allowed_list the list of permitted rules if it exists, otherwise NULL.
++ * @returns TRUE on success, False otherwise.
 + */
-+DBusList**
++dbus_bool_t
 +bus_smack_generate_allowed_list (DBusConnection *connection,
 +                                 DBusHashTable  *rules_by_smack_label,
-+                                 dbus_bool_t *nomem_err)
++                                 DBusList **allowed_list)
 +{
 +#ifdef DBUS_ENABLE_SMACK
-+  char *subject_label;
++  const char *subject_label;
 +  DBusHashIter iter;
 +  dbus_bool_t is_allowed;
-+  DBusList **allowed_list;
++  DBusList *rule_list;
 +
 +  /* the label of the subject, is the label on the new connection,
 +     either the service itself or one of its clients */
-+  subject_label = bus_smack_get_label (connection);
++  subject_label = bus_connection_get_smack_label (connection);
 +  if (subject_label == NULL)
 +    return NULL;
 +
-+  allowed_list = dbus_new0 (DBusList*, 1);
-+  if (allowed_list == NULL)
++  rule_list = dbus_new0 (DBusList*, 1);
++  if (rule_list == NULL)
 +    goto nomem;
 +
 +  /* Iterate over all the smack labels we have parsed from the .conf files */
@@ -406,11 +369,11 @@ index b8542c2..d4546a3 100644
 +         by the SMACK label named $object_label */
 +      DBusList **list = _dbus_hash_iter_get_value (&iter);
 +
-+      link = _dbus_list_get_first_link (list);
-+      while (link != NULL)
++      for (link = _dbus_list_get_first_link (list);
++           link != NULL;
++           link = _dbus_list_get_next_link (list, link))
 +        {
 +          BusPolicyRule *rule = link->data;
-+          link = _dbus_list_get_next_link (list, link);
 +          is_allowed = FALSE;
 +
 +          switch (rule->type)
@@ -418,17 +381,17 @@ index b8542c2..d4546a3 100644
 +            case BUS_POLICY_RULE_OWN:
 +              is_allowed = bus_smack_has_access (subject_label,
 +                                                 object_label,
-+                                                 SMACK_READ_WRITE);
++                                                 "RWX");
 +              break;
 +            case BUS_POLICY_RULE_SEND:
 +              is_allowed = bus_smack_has_access (subject_label,
 +                                                 object_label,
-+                                                 SMACK_WRITE);
++                                                 "W");
 +              break;
 +            case BUS_POLICY_RULE_RECEIVE:
 +              is_allowed = bus_smack_has_access (subject_label,
 +                                                 object_label,
-+                                                 SMACK_READ);
++                                                 "R");
 +              break;
 +            default:
 +              continue;
@@ -436,7 +399,7 @@ index b8542c2..d4546a3 100644
 +
 +          if (is_allowed)
 +            {
-+              if (!_dbus_list_append (allowed_list, rule))
++              if (!_dbus_list_append (rule_list, rule))
 +                goto nomem;
 +
 +              bus_policy_rule_ref (rule);
@@ -446,40 +409,43 @@ index b8542c2..d4546a3 100644
 +        }
 +    }
 +
-+  dbus_free(subject_label);
-+  return allowed_list;
++  *allowed_list = rule_list;
++  return TRUE;
 +
 +nomem:
-+  if (allowed_list != NULL)
-+    _dbus_list_clear (allowed_list);
-+
-+  dbus_free(subject_label);
-+  *nomem_err = TRUE;
-+  return NULL;
-+
++  if (rule_list != NULL)
++    {
++      _dbus_list_clear (&rule_list);
++      dbus_free (rule_list);
++    }
++  return FALSE;
 +#else
-+  return NULL;
++  return TRUE;
 +#endif
 +}
 diff --git a/bus/smack.h b/bus/smack.h
-index 04a4a2a..6b1dfad 100644
+index 51773b9..9b3ceb7 100644
 --- a/bus/smack.h
 +++ b/bus/smack.h
-@@ -27,10 +27,14 @@
+@@ -27,11 +27,14 @@
  #define SMACK_H
  
  #include "bus.h"
 +#include <dbus/dbus-hash.h>
  
- dbus_bool_t bus_smack_handle_get_connection_context (DBusConnection *connection,
-                                                      BusTransaction *transaction,
-                                                      DBusMessage    *message,
-                                                      DBusError      *error);
+-char *
+-bus_smack_get_label (DBusConnection *connection, DBusError *error);
++char *bus_smack_get_label (DBusConnection *connection, DBusError *error);
+ 
+-void
+-bus_smack_label_free (char *label);
++void bus_smack_label_free (char *label);
++
++dbus_bool_t bus_smack_generate_allowed_list (DBusConnection *connection,
++                                             DBusHashTable *label_rules,
++                                             DBusList **error);
  
-+DBusList **bus_smack_generate_allowed_list (DBusConnection *connection,
-+                                            DBusHashTable *label_rules,
-+                                            dbus_bool_t *error);
  #endif // SMACK_H
 -- 
-1.7.5.4
+1.8.1.5
 
diff --git a/packaging/adding-run-time-check-for-SMACK.patch b/packaging/adding-run-time-check-for-SMACK.patch
new file mode 100644
index 0000000..7a26902
--- /dev/null
+++ b/packaging/adding-run-time-check-for-SMACK.patch
@@ -0,0 +1,121 @@
+From 833fbab50478bd36e9e6602b86fefae073a5ec6e Mon Sep 17 00:00:00 2001
+From: Zofia Abramowska <z.abramowska@samsung.com>
+Date: Fri, 12 Apr 2013 17:38:18 +0200
+Subject: [PATCH] Adding runtime check for SMACK
+
+Change-Id: I3336966bf1741eeb6456a94e9e516cda6cd9907b
+---
+ bus/policy.c |   18 ++++++++++++------
+ bus/smack.c  |   26 +++++++++++++++++++++++++-
+ bus/smack.h  |    2 ++
+ 3 files changed, 39 insertions(+), 7 deletions(-)
+
+diff --git a/bus/policy.c b/bus/policy.c
+index ea7bffe..02c337b 100644
+--- a/bus/policy.c
++++ b/bus/policy.c
+@@ -184,11 +184,14 @@ bus_policy_new (void)
+     goto failed;
+ 
+ #ifdef DBUS_ENABLE_SMACK
+-  policy->rules_by_smack_label = _dbus_hash_table_new (DBUS_HASH_STRING,
+-                                                       (DBusFreeFunction) dbus_free,
+-                                                       free_rule_list_func);
+-  if (policy->rules_by_smack_label == NULL)
+-    goto failed;
++  if (have_smack())
++    {
++      policy->rules_by_smack_label = _dbus_hash_table_new (DBUS_HASH_STRING,
++                                                           (DBusFreeFunction) dbus_free,
++                                                           free_rule_list_func);
++      if (policy->rules_by_smack_label == NULL)
++        goto failed;
++    }
+ #endif
+ 
+   return policy;
+@@ -679,6 +682,8 @@ bus_policy_append_smack_rule (BusPolicy      *policy,
+                               const char     *label,
+                               BusPolicyRule  *rule)
+ {
++  if (!have_smack())
++    return TRUE;
+ #ifdef DBUS_ENABLE_SMACK
+   DBusList **list;
+ 
+@@ -805,7 +810,8 @@ bus_policy_merge (BusPolicy *policy,
+     return FALSE;
+ 
+ #ifdef DBUS_ENABLE_SMACK
+-  if (!merge_string_hash (policy->rules_by_smack_label,
++  if (have_smack() && 
++      !merge_string_hash (policy->rules_by_smack_label,
+                           to_absorb->rules_by_smack_label))
+     return FALSE;
+ #endif
+diff --git a/bus/smack.c b/bus/smack.c
+index 5e67ebd..78bb19a 100644
+--- a/bus/smack.c
++++ b/bus/smack.c
+@@ -40,13 +40,34 @@
+ #include <sys/smack.h>
+ #endif
+ 
++int
++have_smack(void)
++{
++#ifdef DBUS_ENABLE_SMACK
++  static int have = -1;
++
++  if (have == -1)
++    {
++      if(smack_smackfs_path() == NULL)
++        have = 0;
++      else
++        have = 1;
++    }
++  return have;
++#else
++  return 0;
++#endif
++}
++
+ char *
+ bus_smack_get_label (DBusConnection *connection, DBusError *error)
+ {
+ #ifdef DBUS_ENABLE_SMACK
+   char *label;
+   int sock_fd;
+-
++  
++  if (!have_smack())
++    return NULL;
+   if (!dbus_connection_get_socket(connection, &sock_fd))
+     {
+       dbus_set_error (error, DBUS_ERROR_FAILED,
+@@ -83,6 +104,9 @@ static dbus_bool_t
+ bus_smack_has_access (const char *subject, const char *object,
+                       const char *access)
+ {
++  
++  if (!have_smack())
++    return TRUE;
+   return (smack_have_access (subject, object, access) == 1 ? TRUE : FALSE);
+ }
+ #endif
+diff --git a/bus/smack.h b/bus/smack.h
+index 9b3ceb7..6ebaa61 100644
+--- a/bus/smack.h
++++ b/bus/smack.h
+@@ -29,6 +29,8 @@
+ #include "bus.h"
+ #include <dbus/dbus-hash.h>
+ 
++int have_smack(void);
++
+ char *bus_smack_get_label (DBusConnection *connection, DBusError *error);
+ 
+ void bus_smack_label_free (char *label);
+-- 
+1.7.5.4
+
diff --git a/packaging/dbus.spec b/packaging/dbus.spec
index 3dacb52..1d80b1f 100755
--- a/packaging/dbus.spec
+++ b/packaging/dbus.spec
@@ -11,15 +11,20 @@ Source2:	dbus-user.socket
 Source3:	dbus-user.service
 Source4:	system.conf
 Source1001:	dbus.manifest
-Patch1:         0001-Enable-checking-of-smack-context-from-DBus-interface.patch
-Patch2:         0002-Enforce-smack-policy-from-conf-file.patch
-Patch3:         0003-dbus_service_highest_prio_setting.patch
-Patch4:         slp-relax-permissions.patch
-Patch5:         slp-add-services-directory.patch
-Patch6:         0006-build-Make-disable-xml-docs-build-work-again.patch
-Patch7:         0007-Set-correct-address-when-using-address-systemd.patch
-Patch8:         0008-smack-Allow-everybody-send-messages-to-system-dbus-s.patch
-Patch9:         0009-Dbus-environment-value-define.patch
+Patch1:         0001-dbus_service_highest_prio_setting.patch
+Patch2:         0002-slp-relax-permissions.patch
+Patch3:         0003-slp-add-services-directory.patch
+Patch4:         0004-build-Make-disable-xml-docs-build-work-again.patch
+Patch5:         0005-Set-correct-address-when-using-address-systemd.patch
+Patch6:         0006-smack-Allow-everybody-send-messages-to-system-dbus-s.patch
+Patch7:         0007-Dbus-environment-value-define.patch
+Patch8:         0008-bus-driver-factor-out-common-code-to-get-a-named-con.patch
+Patch9:         0009-Convert-a-sv-helpers-from-Stats-into-generic-utility.patch
+Patch10:        0010-GetConnectionCredentials-add.patch
+Patch11:        0011-Store-Smack-context-of-connection.patch
+Patch12:        0012-Return-Smack-context-with-connection-credentials.patch
+Patch13:        0013-Enforce-Smack-policy-from-conf-file.patch
+Patch14:        adding-run-time-check-for-SMACK.patch
 Requires:	%{name}-libs = %{version}
 BuildRequires:  expat-devel >= 1.95.5
 BuildRequires:  libtool
@@ -64,6 +69,12 @@ Headers and static libraries for D-Bus.
 %patch7 -p1
 %patch8 -p1
 %patch9 -p1
+%patch10 -p1
+%patch11 -p1
+%patch12 -p1
+%patch13 -p1
+%patch14 -p1
+
 
 %build
 cp %{SOURCE1001} .
-- 
1.7.5.4

